<!DOCTYPE html><html lang="en" ng-app="angularIOApp" itemscope itemtype="http://schema.org/Framework"><!-- template: public/docs/_layout--><head><title>Dependency Injection - dart</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta name="keywords" content="Angular, AngularJS, AngularDart, Javscript, Dart, Framework, JavaScript MVC, Google"/><meta name="robots" content="all"/><meta name="referrer" content="origin"/><meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Angular 2"/><meta property="og:image" content="/resources/images/logos/standard/shield-large.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="184"/><meta property="og:image:height" content="200"/><meta property="og:description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="name" content="Angular 2"/><meta itemprop="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="image" content="https://angular.io/resources/images/logos/standard/shield-large.png"/><link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico"/><link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,300,500,400italic,700" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/><link rel="stylesheet" href="/resources/css/vendor/icomoon/style.css"/><link rel="stylesheet" href="/resources/css/vendor/animate.css"/><link rel="stylesheet" href="/resources/css/main.css"/><!-- MOBILE ICONS -->
<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/resources/images/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/resources/images/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-194x194.png" sizes="194x194">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/resources/images/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/resources/images/favicons/manifest.json"></head><body ng-controller="AppCtrl as appCtrl" class="l-offset-nav l-offset-side-nav"><nav scroll-y-offset-element="scroll-y-offset-element" class="main-nav l-pinned-top l-layer-5"><h1><a href="/" md-button>Angular <sup>by Google</sup></a></h1><button aria-label="View Menu" ng-click="appCtrl.toggleMainMenu($event)" md-button="md-button" class="main-nav-button main-nav-mobile-trigger l-right">Site Menu <span class="icon icon-arrow-drop-down"></span></button><ul ng-class="appCtrl.showMainNav ? 'is-visible' : ''"><li class="l-left"><a class="main-nav-button" href="/features.html" md-button>Features</a></li><li class="l-left"><a class="main-nav-button" href="/docs/ts/latest/" md-button>Docs</a></li><li class="l-left"><a class="main-nav-button" href="/events.html" md-button>Events</a></li><li class="l-left"><a class="main-nav-button" href="/news.html" md-button>News</a></li><li class="l-right"><a class="main-nav-button" href="/docs/ts/latest/quickstart.html" md-button>Get Started</a></li></ul></nav><!-- Include this file ONLY when current.path[2] is defined--><nav ng-class="appCtrl.showDocsNav ? 'is-visible' : ''" class="sidenav l-pinned-left l-layer-4 l-offset-nav"><!-- SEARCH BAR--><header class="sidenav-search st-input-wrapper"><form class="st-input-inner"><label for="search-io" class="is-hidden">Search Docs</label><input type="search" id="search-io" placeholder="SEARCH DOCS..."/></form><button aria-label="View Docs Menu" ng-click="appCtrl.toggleDocsMenu($event)" md-button="md-button" class="mobile-trigger button">Docs <span class="icon icon-arrow-drop-down"></span></button></header><ul class="sidenav-links"><li class="sidenav-section no-border"><a href="/docs/dart/latest/" class="nav-title">Docs Home</a></li><!-- CORE DOCUMENTATION--><li class="sidenav-section-divider"><h3>Core Documentation</h3></li><li class="sidenav-section"><a href="/docs/dart/latest/quickstart.html" title="Get up and running with Angular 2" class="nav-title ">Quickstart</a></li><li class="sidenav-section"><a href="/docs/dart/latest/guide/" title="How to read and use this documentation" class="nav-title is-parent is-selected">Guide<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists"><ul><li class="nav-list-item "><a href="/docs/dart/latest/guide/" title="How to read and use this documentation">1. Overview</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/architecture.html" title="The basic building blocks of Angular 2 applications">2. Architecture</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/displaying-data.html" title="Interpolation and other forms of property binding help us show app data in the UI.">3. Displaying Data</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/user-input.html" title="User input triggers DOM events. We listen to those events with event bindings that funnel updated values back into our components and models.">4. User Input</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/forms.html" title="A form creates a cohesive, effective, and compelling data entry experience. An Angular form coordinates a set of data-bound user controls, tracks changes, validates input, and presents errors.">5. Forms</a></li><li class="nav-list-item is-selected"><a href="/docs/dart/latest/guide/dependency-injection.html" title="Angular's dependency injection system creates and delivers dependent services &quot;just-in-time&quot;.">6. Dependency Injection</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/template-syntax.html" title="Learn how to write templates that display data and consume user events with the help of data binding.">7. Template Syntax</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/cheatsheet.html" title="A quick guide to Angular syntax. (Content is provisional and may change.)">8. Angular Cheat Sheet</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/style-guide.html" title="Write Angular 2 with style.">9. Style Guide</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/glossary.html" title="Brief definitions of the most important words in the Angular 2 vocabulary">10. Glossary</a></li></ul></div></li><li class="sidenav-section no-border"><a href="/docs/dart/latest/api/" title="API Preview" class="nav-title ">API Reference</a></li><!-- ADVANCED DOCUMENATION--><li class="sidenav-section-divider"><h3>Additional Documentation</h3></li><li class="sidenav-section"><a href="/docs/dart/latest/tutorial/" title="The Tour of Heroes tutorial takes us through the steps of creating an Angular application in Dart." class="nav-title is-parent ">Tutorial<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/dart/latest/tutorial/" title="The Tour of Heroes tutorial takes us through the steps of creating an Angular application in Dart.">1. Introduction</a></li><li class="nav-list-item "><a href="/docs/dart/latest/tutorial/toh-pt1.html" title="We build a simple hero editor">2. The Hero Editor</a></li><li class="nav-list-item "><a href="/docs/dart/latest/tutorial/toh-pt2.html" title="We build a master/detail page with a list of heroes">3. Master/Detail</a></li><li class="nav-list-item "><a href="/docs/dart/latest/tutorial/toh-pt3.html" title="We refactor the master/detail view into separate components">4. Multiple Components</a></li><li class="nav-list-item "><a href="/docs/dart/latest/tutorial/toh-pt4.html" title="We create a reusable service to manage our hero data calls">5. Services</a></li><li class="nav-list-item "><a href="/docs/dart/latest/tutorial/toh-pt5.html" title="We add the Angular Component Router and learn to navigate among the views">6. Routing</a></li><li class="nav-list-item "><a href="/docs/dart/latest/tutorial/toh-pt6.html" title="We convert our service and components to use Angular's HTTP service">7. HTTP</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/dart/latest/guide/attribute-directives.html" title="Attribute directives attach behavior to elements." class="nav-title is-parent ">Advanced Documentation<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/dart/latest/guide/attribute-directives.html" title="Attribute directives attach behavior to elements.">Attribute Directives</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/browser-support.html" title="Browser support and polyfills guide.">Browser support</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/component-styles.html" title="Learn how to apply CSS styles to components.">Component Styles</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/hierarchical-dependency-injection.html" title="Angular's hierarchical dependency injection system supports nested injectors in parallel with the component tree.">Hierarchical Injectors</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/server-communication.html" title="Talk to a remote server with an HTTP Client.">HTTP Client</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/lifecycle-hooks.html" title="Angular calls lifecycle hook methods on directives and components as it creates, changes, and destroys them.">Lifecycle Hooks</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/pipes.html" title="Pipes transform displayed values within a template.">Pipes</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/router.html" title="Discover the basics of screen navigation with the Angular 2 Component Router.">Routing &amp; Navigation</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/security.html" title="Developing for content security in Angular applications">Security</a></li><li class="nav-list-item "><a href="/docs/dart/latest/guide/structural-directives.html" title="Angular has a powerful template engine that lets us easily manipulate the DOM structure of our elements.">Structural Directives</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/dart/latest/cookbook/" title="A collection of recipes for common Angular application scenarios" class="nav-title is-parent ">Cookbook<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/dart/latest/cookbook/" title="A collection of recipes for common Angular application scenarios">Overview</a></li><li class="nav-list-item "><a href="/docs/dart/latest/cookbook/component-communication.html" title="Share information between different directives and components">Component Interaction</a></li><li class="nav-list-item "><a href="/docs/dart/latest/cookbook/set-document-title.html" title="Setting the document or window title using the Title service.">Set the Document Title</a></li></ul></div></li></ul><!-- DROPDOWN BUTTON --><nav class="dropdown"><button aria-label="Select a version of Angular" md-button="md-button" ng-click="appCtrl.toggleVersionMenu($event)" class="dropdown-button">Angular 2 for Dart  <span class="icon icon-arrow-drop-down"></span></button><div ng-click="appCtrl.toggleVersionMenu($event)" ng-show="appCtrl.showMenu" class="overlay ng-hide"></div><!-- DROPDOWN MENU --><ul ng-class="appCtrl.showMenu ? 'is-visible' : ''" class="dropdown-menu"><li><a href="/docs/ts/latest/guide/dependency-injection.html" md-button>Angular 2 for TypeScript </a></li><li><a href="/docs/js/latest/guide/dependency-injection.html" md-button>Angular 2 for JavaScript </a></li><li><a href="/docs/dart/latest/guide/dependency-injection.html" md-button>Angular 2 for Dart </a></li></ul></nav></nav><script>// Could put in appCtrl but only needed here and clear here
(function scrollToSelectedLink() {
  var sideNav = document.getElementsByClassName('sidenav')[0];
  var link = sideNav.getElementsByClassName('is-selected')[0];
  if(link && link.offsetTop > window.innerHeight){
    sideNav.scrollTop = link.offsetTop - (window.innerHeight/2);
    //alert("offsetTop: " + link.offsetTop + " side-nav top is " + sideNav.scrollTop);
  }
})()</script><!-- template: public/_includes/_hero--><header class="hero background-sky"><h1 class="hero-title ">Dependency Injection</h1><!--CLEAR FLOAT ELEMENTS--><div class="clear"></div></header><div class="banner"><p class="text-body">Angular's dependency injection system creates and delivers dependent services "just-in-time".</p></div><article class="l-content-small grid-fluid docs-content"><script>function why(id, backTo) {
  var id = "#"+id;
  var el = document.querySelector(id);
  el.hidden=el.hidden=!el.hidden;

  if (el.hidden && backTo){
    // the next line is required to work around a bug in WebKit (Chrome / Safari)
    location.href = "#";
    location.href =  "#" + backTo;
  }
}</script><script>function verbose(isVerbose) {
  isVerbose = !! isVerbose;
  var el = document.querySelector('button.verbose.off');
  el.style.display = isVerbose ? 'block' : 'none';
  var el = document.querySelector('button.verbose.on');
  el.style.display = isVerbose ? 'none' : 'block';

  CCSStylesheetRuleStyle('main','.l-verbose-section', 'display',
    isVerbose ? 'block' : 'none');
}
</script><script>function CCSStylesheetRuleStyle(stylesheet, selectorText, style, value){
  /* returns the value of the element style of the rule in the stylesheet
  *  If no value is given, reads the value
  *  If value is given, the value is changed and returned
  *  If '' (empty string) is given, erases the value.
  *  The browser will apply the default one
  *
  * string stylesheet: part of the .css name to be recognized, e.g. 'default'
  * string selectorText: css selector, e.g. '#myId', '.myClass', 'thead td'
  * string style: camelCase element style, e.g. 'fontSize'
  * string value optional : the new value
  */
  var CCSstyle = undefined, rules, sheet;
  for(var m in document.styleSheets){
    sheet = document.styleSheets[m];
    if(sheet.href && sheet.href.indexOf(stylesheet) != -1){
    rules = sheet[document.all ? 'rules' : 'cssRules'];
    for(var n in rules){
      console.log(rules[n].selectorText);
      if(rules[n].selectorText == selectorText){
        CCSstyle = rules[n].style;
        break;
      }
    }
    break;
    }
  }
  if(value == undefined)
    return CCSstyle[style]
  else
    return CCSstyle[style] = value
}
</script><p><strong>Dependency injection</strong> is an important application design pattern.
Angular has its own dependency injection framework, and
we really can&#39;t build an Angular application without it.
It&#39;s used so widely that almost everyone just calls it <em>DI</em>.</p>
<p>In this chapter we&#39;ll learn what DI is and why we want it.
Then we&#39;ll learn <a href="#angular-di">how to use it</a> in an Angular app.</p>
<ul>
<li><a href="#why-dependency-injection">Why dependency injection?</a></li>
<li><a href="#angular-dependency-injection">Angular dependency injection</a></li>
<li><a href="#injector-providers">Injector providers</a></li>
<li><a href="#dependency-injection-tokens">Dependency injection tokens</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
<p>Run the <live-example></live-example>.</p>
<div id="why-di" class="l-main-section"></div><h2 id="why-dependency-injection-">Why dependency injection?</h2>
<p>Let&#39;s start with the following code.</p>
<div class="code-example"><header><h4>lib/car/car.dart (without DI)</h4></header><code-example language="dart" format="linenums">class Car {
  Engine engine;
  Tires tires;
  var description = &#39;No DI&#39;;

  Car() {
    engine = new Engine();
    tires = new Tires();
  }

  // Method using the engine and tires
  String drive() =&gt; &#39;$description car with &#39;
    &#39;${engine.cylinders} cylinders and &#39;
    &#39;${tires.make} tires.&#39;;
}
</code-example></div><p>Our <code>Car</code> creates everything it needs inside its constructor.
What&#39;s the problem?
The problem is that our <code>Car</code> class is brittle, inflexible, and hard to test.</p>
<p>Our <code>Car</code> needs an engine and tires. Instead of asking for them,
the <code>Car</code> constructor instantiates its own copies from
the very specific classes <code>Engine</code> and <code>Tires</code>.</p>
<p>What if the <code>Engine</code> class evolves and its constructor requires a parameter?
Our <code>Car</code> is broken and stays broken until we rewrite it along the lines of
<code>engine = new Engine(theNewParameter)</code>.
We didn&#39;t care about <code>Engine</code> constructor parameters when we first wrote <code>Car</code>.
We don&#39;t really care about them now.
But we&#39;ll <em>have</em> to start caring because
when the definition of <code>Engine</code> changes, our <code>Car</code> class must change.
That makes <code>Car</code> brittle.</p>
<p>What if we want to put a different brand of tires on our <code>Car</code>? Too bad.
We&#39;re locked into whatever brand the <code>Tires</code> class creates. That makes our <code>Car</code> inflexible.</p>
<p>Right now each new car gets its own engine. It can&#39;t share an engine with other cars.
While that makes sense for an automobile engine,
we can think of other dependencies that should be shared, such as the onboard
wireless connection to the manufacturer&#39;s service center. Our <code>Car</code> lacks the flexibility
to share services that have been created previously for other consumers.</p>
<p>When we write tests for our <code>Car</code> we&#39;re at the mercy of its hidden dependencies.
Is it even possible to create a new <code>Engine</code> in a test environment?
What does <code>Engine</code>itself depend upon? What does that dependency depend on?
Will a new instance of <code>Engine</code> make an asynchronous call to the server?
We certainly don&#39;t want that going on during our tests.</p>
<p>What if our <code>Car</code> should flash a warning signal when tire pressure is low?
How do we confirm that it actually does flash a warning
if we can&#39;t swap in low-pressure tires during the test?</p>
<p>We have no control over the car&#39;s hidden dependencies.
When we can&#39;t control the dependencies, a class becomes difficult to test.</p>
<p>How can we make <code>Car</code> more robust, flexible, and testable?</p>
<p><a id="ctor-injection"></a>
That&#39;s super easy. We change our <code>Car</code> constructor to a version with DI:</p>
<code-tabs><code-pane language="dart" name="lib/car/car.dart (excerpt with DI)" format=".">final Engine engine;
final Tires tires;
String description = &#39;DI&#39;;

Car(this.engine, this.tires);
</code-pane><code-pane language="dart" name="lib/car/car.dart (excerpt without DI)" format=".">Engine engine;
Tires tires;
var description = &#39;No DI&#39;;

Car() {
  engine = new Engine();
  tires = new Tires();
}
</code-pane></code-tabs><p>See what happened? We moved the definition of the dependencies to the constructor.
Our <code>Car</code> class no longer creates an engine or tires.
It just consumes them.</p>
<div class="l-sub-section"><p>We also leveraged Dart&#39;s constructor syntax for declaring parameters and
initializing properties simultaneously.</p>
</div><p>Now we create a car by passing the engine and tires to the constructor.</p>
<div class="code-example"><code-example language="dart" format="">// Simple car with 4 cylinders and Flintstone tires.
new Car(new Engine(), new Tires())
</code-example></div><p>How cool is that?
The definition of the engine and tire dependencies are
decoupled from the <code>Car</code> class itself.
We can pass in any kind of engine or tires we like, as long as they
conform to the general API requirements of an engine or tires.</p>
<p>If someone extends the <code>Engine</code> class, that is not <code>Car</code>&#39;s problem.</p>
<div class="l-sub-section"><p>The <em>consumer</em> of <code>Car</code> has the problem. The consumer must update the car creation code to
something like this:</p>
<div class="code-example"><code-example language="dart" format="">class Engine2 extends Engine {
  Engine2(cylinders) : super.withCylinders(cylinders);
}

Car superCar() =&gt;
  // Super car with 12 cylinders and Flintstone tires.
  <span class="otl">new Car(new Engine2(12), new Tires())</span>
  ..description = &#39;Super&#39;;
</code-example></div><p>The critical point is this: <code>Car</code> itself did not have to change.
We&#39;ll take care of the consumer&#39;s problem soon enough.</p>
</div><p>The <code>Car</code> class is much easier to test because we are in complete control
of its dependencies.
We can pass mocks to the constructor that do exactly what we want them to do
during each test:</p>
<div class="code-example"><code-example language="dart" format="">class MockEngine extends Engine {
  MockEngine() : super.withCylinders(8);
}

class MockTires extends Tires {
  MockTires() { make = &#39;YokoGoodStone&#39;; }
}

Car testCar() =&gt;
  // Test car with 8 cylinders and YokoGoodStone tires.
  <span class="otl">new Car(new MockEngine(), new MockTires())</span>
  ..description = &#39;Test&#39;;
</code-example></div><p><strong>We just learned what dependency injection is</strong>.</p>
<p>It&#39;s a coding pattern in which a class receives its dependencies from external
sources rather than creating them itself.</p>
<p>Cool! But what about that poor consumer?
Anyone who wants a <code>Car</code> must now
create all three parts: the <code>Car</code>, <code>Engine</code>, and <code>Tires</code>.
The <code>Car</code> class shed its problems at the consumer&#39;s expense.
We need something that takes care of assembling these parts for us.</p>
<p>We could write a giant class to do that:</p>
<div class="code-example"><header><h4>lib/car/car_factory.dart</h4></header><code-example language="dart" format="linenums">import &#39;car.dart&#39;;

// BAD pattern!
class CarFactory {
  Car createCar() =&gt;
      new Car(createEngine(), createTires())
        ..description = &#39;Factory&#39;;

  Engine createEngine() =&gt; new Engine();
  Tires createTires() =&gt; new Tires();
}
</code-example></div><p>It&#39;s not so bad now with only three creation methods.
But maintaining it will be hairy as the application grows.
This factory is going to become a huge spiderweb of
interdependent factory methods!</p>
<p>Wouldn&#39;t it be nice if we could simply list the things we want to build without
having to define which dependency gets injected into what?</p>
<p>This is where the dependency injection framework comes into play.
Imagine the framework had something called an <em>injector</em>.
We register some classes with this injector, and it figures out how to create them.</p>
<p>When we need a <code>Car</code>, we simply ask the injector to get it for us and we&#39;re good to go.</p>
<div class="code-example"><code-example language="dart" format="">var car = injector.get(Car);
</code-example></div><p>Everyone wins. The <code>Car</code> knows nothing about creating an <code>Engine</code> or <code>Tires</code>.
The consumer knows nothing about creating a <code>Car</code>.
We don&#39;t have a gigantic factory class to maintain.
Both <code>Car</code> and consumer simply ask for what they need and the injector delivers.</p>
<p>This is what a <strong>dependency injection framework</strong> is all about.</p>
<p>Now that we know what dependency injection is and appreciate its benefits,
let&#39;s see how it is implemented in Angular.</p>
<div id="angular-di" class="l-main-section"></div><h2 id="angular-dependency-injection">Angular dependency injection</h2>
<p>Angular ships with its own dependency injection framework. This framework can also be used
as a standalone module by other applications and frameworks.</p>
<p>That sounds nice. What does it do for us when building components in Angular?
Let&#39;s see, one step at a time.</p>
<p>We&#39;ll begin with a simplified version of the <code>HeroesComponent</code>
that we built in the <a href="../tutorial/">The Tour of Heroes</a>.</p>
<code-tabs><code-pane language="dart" name="lib/heroes/heroes_component.dart" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero_list_component.dart&#39;;

@Component(
    selector: &#39;my-heroes&#39;,
    template: &#39;&#39;&#39;
      &lt;h2&gt;Heroes&lt;/h2&gt;
      &lt;hero-list&gt;&lt;/hero-list&gt;&#39;&#39;&#39;,
    directives: const [HeroListComponent])
class HeroesComponent {}
</code-pane><code-pane language="dart" name="lib/heroes/hero_list_component.dart" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero.dart&#39;;
import &#39;mock_heroes.dart&#39;;

@Component(
    selector: &#39;hero-list&#39;,
    template: &#39;&#39;&#39;
      &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;
        {{hero.id}} - {{hero.name}}
      &lt;/div&gt;&#39;&#39;&#39;)
class HeroListComponent {
  final List&lt;Hero&gt; heroes = HEROES;
}
</code-pane><code-pane language="dart" name="lib/heroes/hero.dart" format="linenums">class Hero {
  final int id;
  final String name;
  final bool isSecret;

  Hero(this.id, this.name, [this.isSecret = false]);
}
</code-pane><code-pane language="dart" name="lib/heroes/mock_heroes.dart" format="linenums">import &#39;hero.dart&#39;;

List&lt;Hero&gt; HEROES = &lt;Map&gt;[
  {&#39;id&#39;: 11, &#39;isSecret&#39;: false, &#39;name&#39;: &#39;Mr. Nice&#39;},
  {&#39;id&#39;: 12, &#39;isSecret&#39;: false, &#39;name&#39;: &#39;Narco&#39;},
  {&#39;id&#39;: 13, &#39;isSecret&#39;: false, &#39;name&#39;: &#39;Bombasto&#39;},
  {&#39;id&#39;: 14, &#39;isSecret&#39;: false, &#39;name&#39;: &#39;Celeritas&#39;},
  {&#39;id&#39;: 15, &#39;isSecret&#39;: false, &#39;name&#39;: &#39;Magneta&#39;},
  {&#39;id&#39;: 16, &#39;isSecret&#39;: false, &#39;name&#39;: &#39;RubberMan&#39;},
  {&#39;id&#39;: 17, &#39;isSecret&#39;: false, &#39;name&#39;: &#39;Dynama&#39;},
  {&#39;id&#39;: 18, &#39;isSecret&#39;: true, &#39;name&#39;: &#39;Dr IQ&#39;},
  {&#39;id&#39;: 19, &#39;isSecret&#39;: true, &#39;name&#39;: &#39;Magma&#39;},
  {&#39;id&#39;: 20, &#39;isSecret&#39;: true, &#39;name&#39;: &#39;Tornado&#39;}
].map(_initHero).toList();

Hero _initHero(Map heroProperties) =&gt; new Hero(
    heroProperties[&#39;id&#39;], heroProperties[&#39;name&#39;], heroProperties[&#39;isSecret&#39;]);
</code-pane></code-tabs><p>The <code>HeroesComponent</code> is the root component of the <em>Heroes</em> feature area.
It governs all the child components of this area.
Our stripped down version has only one child, <code>HeroListComponent</code>,
which displays a list of heroes.</p>
<p>Right now <code>HeroListComponent</code> gets heroes from <code>HEROES</code>, an in-memory collection
defined in another file.
That may suffice in the early stages of development, but it&#39;s far from ideal.
As soon as we try to test this component or want to get our heroes data from a remote server,
we&#39;ll have to change the implementation of <code>heroes</code> and
fix every other use of the <code>HEROES</code> mock data.</p>
<p>Let&#39;s make a service that hides how we get hero data.</p>
<div class="l-sub-section"><p>Given that the service is a
<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separate concern</a>,
we suggest that you
write the service code in its own file.</p>
</div><div class="code-example"><header><h4>lib/heroes/hero_service.dart</h4></header><code-example language="dart" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero.dart&#39;;
import &#39;mock_heroes.dart&#39;;

@Injectable()
class HeroService {
  List&lt;Hero&gt; getHeroes() =&gt; HEROES;
}
</code-example></div><p>Our <code>HeroService</code> exposes a <code>getHeroes</code> method that returns
the same mock data as before, but none of its consumers need to know that.</p>
<div class="l-sub-section"><p>Notice the <code>@Injectable()</code> annotation above the service class.
We&#39;ll discuss its purpose <a href="#injectable">shortly</a>.</p>
</div><div class="l-sub-section"><p>We aren&#39;t even pretending this is a real service.
If we were actually getting data from a remote server, the API would have to be 
asynchronous,  returning a <a href="https://api.dartlang.org/dart_async/Future.html">Future</a>.
We&#39;d also have to rewrite the way components consume our service.
This is important in general, but not to our current story.</p>
</div><p>A service is nothing more than a class in Angular 2.
It remains nothing more than a class until we register it with an Angular injector.</p>
<div id="bootstrap"></div><h3 id="configuring-the-injector">Configuring the injector</h3>
<p>We don&#39;t have to create an Angular injector.
Angular creates an application-wide injector for us during the bootstrap process.</p>
<div class="code-example"><header><h4>web/main.dart (excerpt)</h4></header><code-example language="dart" format="">bootstrap(AppComponent);
</code-example></div><p>We do have to configure the injector by registering the <strong>providers</strong>
that create the services our application requires.
We&#39;ll explain what <a href="#providers">providers</a> are later in this chapter.
Before we do, let&#39;s see an example of provider registration during bootstrapping:</p>
<div class="code-example"><code-example language="dart" format="">bootstrap(AppComponent,
  [HeroService]); // DISCOURAGED (but works)
</code-example></div><p>The injector now knows about our <code>HeroService</code>.
An instance of our <code>HeroService</code> will be available for injection across our entire application.</p>
<p>Of course we can&#39;t help wondering about that comment telling us not to do it this way.
It <em>will</em> work. It&#39;s just not a best practice.
The bootstrap provider option is intended for configuring and overriding Angular&#39;s own
preregistered services, such as its routing support.</p>
<p>The preferred approach is to register application providers in application components.
Because the <code>HeroService</code> is used within the <em>Heroes</em> feature area &mdash;
and nowhere else &mdash; the ideal place to register it is in the top-level <code>HeroesComponent</code>.</p>
<h3 id="registering-providers-in-a-component">Registering providers in a component</h3>
<p>Here&#39;s a revised <code>HeroesComponent</code> that registers the <code>HeroService</code>.</p>
<div class="code-example"><header><h4>lib/heroes/heroes_component.dart</h4></header><code-example language="dart" format="">import &#39;package:angular2/core.dart&#39;;

import &#39;hero_list_component.dart&#39;;
import &#39;hero_service.dart&#39;;

@Component(
    selector: &#39;my-heroes&#39;,
    template: &#39;&#39;&#39;
      &lt;h2&gt;Heroes&lt;/h2&gt;
      &lt;hero-list&gt;&lt;/hero-list&gt;&#39;&#39;&#39;,
    <span class="otl">providers: const [HeroService]</span>,
    directives: const [HeroListComponent])
class HeroesComponent {}
</code-example></div><p>Look closely at the <code>providers</code> part of the <code>@Component</code> metadata.
An instance of the <code>HeroService</code> is now available for injection in this <code>HeroesComponent</code>
and all of its child components.</p>
<p>The <code>HeroesComponent</code> itself doesn&#39;t happen to need the <code>HeroService</code>.
But its child <code>HeroListComponent</code> does, so we head there next.</p>
<h3 id="preparing-the-herolistcomponent-for-injection">Preparing the HeroListComponent for injection</h3>
<p>The <code>HeroListComponent</code> should get heroes from the injected <code>HeroService</code>.
Per the dependency injection pattern, the component must ask for the service in its 
constructor, <a href="#ctor-injection">as we explained earlier</a>.
It&#39;s a small change:</p>
<code-tabs><code-pane language="dart" name="lib/heroes/hero_list.component (with DI)" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero.dart&#39;;
import &#39;hero_service.dart&#39;;

@Component(
    selector: &#39;hero-list&#39;,
    template: &#39;&#39;&#39;
      &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;
        {{hero.id}} - {{hero.name}}
      &lt;/div&gt;&#39;&#39;&#39;)
class HeroListComponent {
  final List&lt;Hero&gt; heroes;

  HeroListComponent(HeroService heroService)
      : heroes = heroService.getHeroes();
}
</code-pane><code-pane language="dart" name="lib/heroes/hero_list.component (without DI)" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero.dart&#39;;
import &#39;mock_heroes.dart&#39;;

@Component(
    selector: &#39;hero-list&#39;,
    template: &#39;&#39;&#39;
      &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;
        {{hero.id}} - {{hero.name}}
      &lt;/div&gt;&#39;&#39;&#39;)
class HeroListComponent {
  final List&lt;Hero&gt; heroes = HEROES;
}
</code-pane></code-tabs><div class="l-sub-section"><h4 id="focus-on-the-constructor">Focus on the constructor</h4>
<p>Adding a parameter to the constructor isn&#39;t all that&#39;s happening here.</p>
<div class="code-example"><code-example language="dart" format="">HeroListComponent(HeroService heroService)
    : heroes = heroService.getHeroes();
</code-example></div><p>Note that the constructor parameter has the type <code>HeroService</code>, and that
the <code>HeroListComponent</code> class has an <code>@Component</code> annotation
(scroll up to confirm that fact).
Also recall that the parent component (<code>HeroesComponent</code>)
has <code>providers</code> information for <code>HeroService</code>.</p>
<p>The constructor parameter type, the <code>@Component</code> annotation,
and the parent&#39;s <code>providers</code> information combine to tell the
Angular injector to inject an instance of
<code>HeroService</code> whenever it creates a new <code>HeroListComponent</code>.</p>
</div><div id="di-metadata"></div><h3 id="implicit-injector-creation">Implicit injector creation</h3>
<p>When we introduced the idea of an injector above, we showed how to
use it to create a new <code>Car</code>. Here we also show how such an injector
would be explicitly created:</p>
<div class="code-example"><code-example language="dart" format="">  injector = ReflectiveInjector.resolveAndCreate([Car, Engine, Tires]);
  var car = injector.get(Car);
</code-example></div><p>We won&#39;t find code like that in the Tour of Heroes or any of our other samples.
We <em>could</em> write code that <a href="#explicit-injector">explicitly creates an injector</a> if we <em>had</em> to, but we rarely do.
Angular takes care of creating and calling injectors
when it creates components for us &mdash; whether through HTML markup, as in <code>&lt;hero-list&gt;&lt;/hero-list&gt;</code>,
or after navigating to a component with the <a href="./router.html">router</a>.
If we let Angular do its job, we&#39;ll enjoy the benefits of automated dependency injection.</p>
<h3 id="singleton-services">Singleton services</h3>
<p>Dependencies are singletons within the scope of an injector.
In our example, a single <code>HeroService</code> instance is shared among the
<code>HeroesComponent</code> and its <code>HeroListComponent</code> children.</p>
<p>However, Angular DI is an hierarchical injection
system, which means that nested injectors can create their own service instances.
Learn more about that in the <a href="./hierarchical-dependency-injection.html">Hierarchical Injectors</a> chapter.</p>
<h3 id="testing-the-component">Testing the component</h3>
<p>We emphasized earlier that designing a class for dependency injection makes the class easier to test.
Listing dependencies as constructor parameters may be all we need to test application parts effectively.</p>
<p>For example, we can create a new <code>HeroListComponent</code> with a mock service that we can manipulate
under test:</p>
<div class="code-example"><code-example language="dart" format="">var expectedHeroes = [new Hero(0, &#39;A&#39;), new Hero(1, &#39;B&#39;)];
var mockService = new MockHeroService(expectedHeroes);
it(&#39;should have heroes when HeroListComponent created&#39;, () {
  var hlc = new HeroListComponent(mockService);
  expect(hlc.heroes.length).toEqual(expectedHeroes.length);
});
</code-example></div><div class="l-sub-section"><p>Learn more in <a href="../testing/index.html">Testing</a>.</p>
</div><h3 id="when-the-service-needs-a-service">When the service needs a service</h3>
<p>Our <code>HeroService</code> is very simple. It doesn&#39;t have any dependencies of its own.</p>
<p>What if it had a dependency? What if it reported its activities through a logging service?
We&#39;d apply the same <em>constructor injection</em> pattern,
adding a constructor that takes a <code>Logger</code> parameter.</p>
<p>Here is the revision compared to the original.</p>
<code-tabs><code-pane language="dart" name="lib/heroes/hero.service (v2)" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;../logger_service.dart&#39;;
import &#39;hero.dart&#39;;
import &#39;mock_heroes.dart&#39;;

@Injectable()
class HeroService {
  final Logger _logger;

  HeroService(this._logger);
  List&lt;Hero&gt; getHeroes() {
    _logger.log(&#39;Getting heroes ...&#39;);
    return HEROES;
  }
}
</code-pane><code-pane language="dart" name="lib/heroes/hero.service (v1)" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero.dart&#39;;
import &#39;mock_heroes.dart&#39;;

@Injectable()
class HeroService {
  List&lt;Hero&gt; getHeroes() =&gt; HEROES;
}
</code-pane></code-tabs><p>The constructor now asks for an injected instance of a <code>Logger</code> and stores it in a private property called <code>_logger</code>.
We call that property within our <code>getHeroes</code> method when anyone asks for heroes.</p>
<h3 id="injectable">Why @Injectable()?</h3><p><strong><a href="https://angular.io/docs/ts/latest/api/core/index/InjectableMetadata-class.html">@Injectable()</a></strong> marks a class as available to an
injector for instantiation. Generally speaking, an injector will report an
error when trying to instantiate a class that is not marked as
<code>@Injectable()</code>.</p>
<p>Injectors are also responsible for instantiating components
like <code>HeroesComponent</code>. Why haven&#39;t we marked <code>HeroesComponent</code> as
<code>@Injectable()</code>?</p>
<p>We <em>can</em> add it if we really want to. It isn&#39;t necessary because the
<code>HeroesComponent</code> is already marked with <code>@Component</code>, and this
annotation class (like <code>@Directive</code> and <code>@Pipe</code>, which we&#39;ll learn about later)
is a subtype of <a href="https://angular.io/docs/ts/latest/api/core/index/InjectableMetadata-class.html">InjectableMetadata</a>.  It is in
fact <code>InjectableMetadata</code> annotations that
identify a class as a target for instantiation by an injector.</p>
<div class="callout is-critical"><header>Always include the parentheses</header><p>Always write <code>@Injectable()</code>, not just <code>@Injectable</code>.
A metadata annotation must be either a reference to a
compile-time constant variable or a call to a constant
constructor such as <code>Injectable()</code>.</p>
<p>If we forget the parentheses, the analyzer will complain:
&quot;Annotation creation must have arguments&quot;. If we try to run the
app anyway, it won&#39;t work, and the console will say
&quot;expression must be a compile-time constant&quot;.</p>
</div><div id="logger-service" class="l-main-section"></div><h2 id="creating-and-registering-a-logger-service">Creating and registering a logger service</h2>
<p>We&#39;re injecting a logger into our <code>HeroService</code> in two steps:</p>
<ol>
<li>Create the logger service.</li>
<li>Register it with the application.</li>
</ol>
<p>Our logger service is quite simple:</p>
<div class="code-example"><header><h4>lib/logger_service.dart</h4></header><code-example language="dart" format="linenums">import &#39;package:angular2/core.dart&#39;;

@Injectable()
class Logger {
  List&lt;String&gt; _logs = [];
  List&lt;String&gt; get logs =&gt; _logs;

  void log(String message) {
    _logs.add(message);
    print(message);
  }
}
</code-example></div><div class="l-sub-section"><p>A real implementation would probably use the
<a href="https://pub.dartlang.org/packages/logging">logging package</a>.</p>
</div><p>We&#39;re likely to need the same logger service everywhere in our application,
so we put it in the project&#39;s <code>lib</code> folder, and
we register it in the <code>providers</code> list of the metadata for our application root component, <code>AppComponent</code>.</p>
<div class="code-example"><header><h4>lib/app_component.dart (excerpt) (providers-logger)</h4></header><code-example language="dart" format="">providers: const [Logger]
</code-example></div><p>If we forget to register the logger, Angular throws an exception when it first looks for the logger:</p>
<code-example format="nocode">EXCEPTION: No provider for Logger! (HeroListComponent -> HeroService -> Logger)
</code-example><p>That&#39;s Angular telling us that the dependency injector couldn&#39;t find the <em>provider</em> for the logger.
It needed that provider to create a <code>Logger</code> to inject into a new
<code>HeroService</code>, which it needed to
create and inject into a new <code>HeroListComponent</code>.</p>
<p>The chain of creations started with the <code>Logger</code> provider. <em>Providers</em> are the subject of our next section.</p>
<div id="providers" class="l-main-section"></div><h2 id="injector-providers">Injector providers</h2>
<p>A provider <em>provides</em> the concrete, runtime version of a dependency value.
The injector relies on <strong>providers</strong> to create instances of the services
that the injector injects into components and other services.</p>
<p>We must register a service <em>provider</em> with the injector, or it won&#39;t know how to create the service.</p>
<p>Earlier we registered the <code>Logger</code> service in the <code>providers</code> list of the metadata for the <code>AppComponent</code> like this:</p>
<div class="code-example"><code-example language="dart" format="">providers: const [Logger]
</code-example></div><p>There are many ways to <em>provide</em> something that implements <code>Logger</code>.
The <code>Logger</code> class itself is an obvious and natural provider.
But it&#39;s not the only way.</p>
<p>We can configure the injector with alternative providers that can deliver  a <code>Logger</code>.
We could provide a substitute class. 
We could give it a provider that calls a logger factory function.
Any of these approaches might be a good choice under the right circumstances.</p>
<p>What matters is that the injector has a provider to go to when it needs a <code>Logger</code>.</p>
<div id="provide"></div><h3 id="the-provider-class-_andprovidefn-">The <em>Provider</em> class </h3>
<p>We wrote the <code>providers</code> list like this:</p>
<div class="code-example"><code-example language="dart" format="">providers: const [Logger]
</code-example></div><p>This is actually a shorthand expression for a provider registration
that creates a new instance of the
<a href="../api/angular2.core/Provider-class.html">Provider</a> class:</p>
<div class="code-example"><code-example language="dart" format="">const [const Provider(Logger, useClass: Logger)]
</code-example></div><p>We supply two arguments (or more) to the <code>Provider</code> constructor.</p>
<p>The first is the <a href="#token">token</a> that serves as the key for both locating a dependency value
and registering the provider.</p>
<p>The second is a named parameter, such as <code>useClass</code>, 
which we can think of as a <em>recipe</em> for creating the dependency value. 
There are many ways to create dependency values ... and many ways to write a recipe.</p>
<div id="class-provider"></div><h3 id="alternative-class-providers">Alternative class providers</h3>
<p>Occasionally we&#39;ll ask a different class to provide the service.
The following code tells the injector
to return a <code>BetterLogger</code> when something asks for the <code>Logger</code>.</p>
<div class="code-example"><code-example language="dart" format="">const [const Provider(Logger, useClass: BetterLogger)]
</code-example></div><div class="callout is-helpful"><header>Dart difference: Constants in metadata</header><p>In Dart, the value of a metadata annotation must be a compile-time constant.
For that reason, we can&#39;t call functions to get values
to use within an annotation.
Instead, we use constant literals or constant constructors.
For example, a TypeScript program will use the
object literal <code>{ provide: Logger, useClass: BetterLogger }</code>.
A Dart annotation would instead use the constant value 
<code>const Provider(Logger, useClass: BetterLogger)</code>.</p>
</div><h3 id="class-provider-with-dependencies">Class provider with dependencies</h3>
<p>Maybe an <code>EvenBetterLogger</code> could display the user name in the log message.
This logger gets the user from the injected <code>UserService</code>,
which happens also to be injected at the application level.</p>
<div class="code-example"><code-example language="dart" format="">@Injectable()
class EvenBetterLogger extends Logger {
  final UserService _userService;

  EvenBetterLogger(this._userService);

  @override void log(String message) {
    var name = _userService.user.name;
    super.log(&#39;Message to $name: $message&#39;);
  }
}
</code-example></div><p>Configure it like we did <code>BetterLogger</code>.</p>
<div class="code-example"><code-example language="dart" format="">const [UserService, const Provider(Logger, useClass: EvenBetterLogger)]
</code-example></div><h3 id="aliased-class-providers">Aliased class providers</h3>
<p>Suppose an old component depends upon an <code>OldLogger</code> class.
<code>OldLogger</code> has the same interface as the <code>NewLogger</code>, but for some reason
we can&#39;t update the old component to use it.</p>
<p>When the <em>old</em> component logs a message with <code>OldLogger</code>,
we want the singleton instance of <code>NewLogger</code> to handle it instead.</p>
<p>The dependency injector should inject that singleton instance
when a component asks for either the new or the old logger.
The <code>OldLogger</code> should be an alias for <code>NewLogger</code>.</p>
<p>We certainly do not want two different <code>NewLogger</code> instances in our app.
Unfortunately, that&#39;s what we get if we try to alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>.</p>
<div class="code-example"><code-example language="dart" format="">const [NewLogger,
  // Not aliased! Creates two instances of `NewLogger`
  const Provider(OldLogger, useClass: NewLogger)]
</code-example></div><p>The solution: alias with the <code>useExisting</code> option.</p>
<div class="code-example"><code-example language="dart" format="">const [NewLogger,
  // Alias OldLogger with reference to NewLogger
  const Provider(OldLogger, <span class="otl">useExisting: NewLogger</span>)]
</code-example></div><div id="value-provider"></div><h3 id="value-providers">Value providers</h3>
<p>Sometimes it&#39;s easier to provide a ready-made object rather than ask the injector to create it from a class.</p>
<div class="callout is-helpful"><header>Dart difference: Constants in metadata</header><p>Because Dart annotations must be compile-time constants,
<code>useValue</code> is often used with string or list literals.
However, <code>useValue</code> works with any constant object.</p>
<p>To create a class that can provide constant objects,
ensure all its instance variables are <code>final</code>,
and give it a <code>const</code> constructor.</p>
<p>Create a constant instance of the class by using <code>const</code> instead of <code>new</code>.</p>
</div><div class="code-example"><code-example language="dart" format="">class SilentLogger implements Logger {
  @override
  final List&lt;String&gt; logs = const [&#39;Silent logger says &quot;Shhhhh!&quot;. Provided via &quot;useValue&quot;&#39;];

  const SilentLogger();

  @override
  void log(String message) { }
}

const silentLogger = const SilentLogger();
</code-example></div><p>Then we register a provider with the <code>useValue</code> option,
which makes this object play the logger role.</p>
<div class="code-example"><code-example language="dart" format="">const [const Provider(Logger, <span class="otl">useValue: silentLogger</span>)]
</code-example></div><p>See more <code>useValue</code> examples in the
<a href="#non-class-dependencies">Non-class dependencies</a> and
<a href="#opaquetoken">OpaqueToken</a> sections.</p>
<div id="factory-provider"></div><h3 id="factory-providers">Factory providers</h3>
<p>Sometimes we need to create the dependent value dynamically,
based on information we won&#39;t have until the last possible moment.
Maybe the information changes repeatedly in the course of the browser session.</p>
<p>Suppose also that the injectable service has no independent access to the source of this information.</p>
<p>This situation calls for a <strong>factory provider</strong>.</p>
<p>Let&#39;s illustrate by adding a new business requirement:
the HeroService must hide <em>secret</em> heroes from normal users.
Only authorized users should see secret heroes.</p>
<p>Like the <code>EvenBetterLogger</code>, the <code>HeroService</code> needs a fact about the user.
It needs to know if the user is authorized to see secret heroes.
That authorization can change during the course of a single application session,
as when we log in a different user.</p>
<p>Unlike <code>EvenBetterLogger</code>, we can&#39;t inject the <code>UserService</code> into the <code>HeroService</code>.
The <code>HeroService</code> won&#39;t have direct access to the user information to decide
who is authorized and who is not.</p>
<div class="l-sub-section"><p>Why? We don&#39;t know either. Stuff like this happens.</p>
</div><p>Instead the <code>HeroService</code> constructor takes a boolean flag to control display of secret heroes.</p>
<div class="code-example"><header><h4>lib/heroes/hero_service.dart (excerpt)</h4></header><code-example language="dart" format="">final Logger _logger;
final bool _isAuthorized;

HeroService(this._logger, this._isAuthorized);

List&lt;Hero&gt; getHeroes() {
  var auth = _isAuthorized ? &#39;authorized&#39; : &#39;unauthorized&#39;;
  _logger.log(&#39;Getting heroes for $auth user.&#39;);
  return HEROES
      .where((hero) =&gt; _isAuthorized || !hero.isSecret)
      .toList();
}
</code-example></div><p>We can inject the <code>Logger</code>, but we can&#39;t inject the  boolean <code>isAuthorized</code>.
We&#39;ll have to take over the creation of new instances of this <code>HeroService</code> with a factory provider.</p>
<p>A factory provider needs a factory function:</p>
<div class="code-example"><header><h4>lib/heroes/hero_service_provider.dart (excerpt)</h4></header><code-example language="dart" format="">HeroService heroServiceFactory(Logger logger, UserService userService) =&gt;
    new HeroService(logger, userService.user.isAuthorized);
</code-example></div><p>Although the <code>HeroService</code> has no access to the <code>UserService</code>, our factory function does.</p>
<p>We inject both the <code>Logger</code> and the <code>UserService</code> into the factory provider and let the injector pass them along to the factory function:</p>
<div class="code-example"><header><h4>lib/heroes/hero_service_provider.dart (excerpt)</h4></header><code-example language="dart" format="">const heroServiceProvider = const Provider(HeroService,
    useFactory: heroServiceFactory,
    deps: const [Logger, UserService]);
</code-example></div><div class="l-sub-section"><p>The <code>useFactory</code> field tells Angular that the provider is a factory function
whose implementation is the <code>heroServiceFactory</code>.</p>
<p>The <code>deps</code> property is a list of <a href="#token">provider tokens</a>.
The <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.
The injector resolves these tokens and injects the corresponding services into the matching factory function parameters.</p>
</div><p>Notice that we captured the factory provider in a constant, <code>heroServiceProvider</code>.
This extra step makes the factory provider reusable.
We can register our <code>HeroService</code> with this constant wherever we need it.</p>
<p>In our sample, we need it only in the <code>HeroesComponent</code>,
where it replaces the previous <code>HeroService</code> registration in the metadata <code>providers</code> list.
Here we see the new and the old implementation side-by-side:</p>
<code-tabs><code-pane language="dart" name="lib/heroes/heroes.component (v3)" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero_list_component.dart&#39;;
import &#39;hero_service_provider.dart&#39;;

@Component(
    selector: &#39;my-heroes&#39;,
    template: &#39;&#39;&#39;
      &lt;h2&gt;Heroes&lt;/h2&gt;
      &lt;hero-list&gt;&lt;/hero-list&gt;&#39;&#39;&#39;,
    <span class="otl">providers: const [heroServiceProvider]</span>,
    directives: const [HeroListComponent])
class HeroesComponent {}
</code-pane><code-pane language="dart" name="lib/heroes/heroes.component (v2)" format="linenums">import &#39;package:angular2/core.dart&#39;;

import &#39;hero_list_component.dart&#39;;
import &#39;hero_service.dart&#39;;

@Component(
    selector: &#39;my-heroes&#39;,
    template: &#39;&#39;&#39;
      &lt;h2&gt;Heroes&lt;/h2&gt;
      &lt;hero-list&gt;&lt;/hero-list&gt;&#39;&#39;&#39;,
    <span class="otl">providers: const [HeroService]</span>,
    directives: const [HeroListComponent])
class HeroesComponent {}
</code-pane></code-tabs><div id="token" class="l-main-section"></div><h2 id="dependency-injection-tokens">Dependency injection tokens</h2>
<p>When we register a provider with an injector, we associate that provider with a dependency injection token.
The injector maintains an internal <em>token-provider</em> map that it references when
asked for a dependency. The token is the key to the map.</p>
<p>In all previous examples, the dependency value has been a class <em>instance</em>, and
the class <em>type</em> served as its own lookup key.
Here we get a <code>HeroService</code> directly from the injector by supplying the <code>HeroService</code> type as the token:</p>
<div class="code-example"><code-example language="dart" format="">heroService = _injector.get(HeroService);
</code-example></div><p>We have similar good fortune when we write a constructor that requires an injected class-based dependency.
We define a constructor parameter with the <code>HeroService</code> class type,
and Angular knows to inject the
service associated with that <code>HeroService</code> class token:</p>
<div class="code-example"><code-example language="dart" format="">HeroListComponent(HeroService heroService)
</code-example></div><p>This is especially convenient when we consider that most dependency values are provided by classes.</p>
<h3 id="non-class-dependencies">Non-class dependencies</h3>
<p>What if the dependency value isn't a class? Sometimes the thing we want to inject is a <span>string, list, map, or maybe a function.</span></p><p>Applications often define configuration objects with lots of small facts 
(like the title of the application or the address of a web API endpoint). They can be 
<b><a href="https://api.dartlang.org/stable/dart-core/Map-class.html">Map</a></b>
literals&nbsp;such as this one:</p><div class="code-example"><header><h4>lib/app_config.dart (excerpt)</h4></header><code-example language="dart" format="">const Map heroDiConfig = const &lt;String,String&gt;{
  &#39;apiEndpoint&#39; : &#39;api.heroes.com&#39;,
  &#39;title&#39; : &#39;Dependency Injection&#39;
};
</code-example></div><p>We&#39;d like to make this configuration object available for injection.
We know we can register an object with a <a href="#value-provider">value provider</a>.</p>
<p>But what should we use as the token? 
While we <em>could</em> use <strong><a href="https://api.dartlang.org/stable/dart-core/Map-class.html">Map</a></strong>, we <em>should not</em> because (like
<code>String</code>) <code>Map</code> is too general. Our app might depend on several maps, each
for a different purpose.</p>
<div class="callout is-helpful"><header>Dart difference: Interfaces are valid tokens</header><p>In TypeScript, interfaces don&#39;t work as provider tokens.
Dart doesn&#39;t have this limitation;
every class implicitly defines an interface,
so interface names are just class names.
<code>Map</code> is a <em>valid</em> token even though it&#39;s the name of an abstract class;
it&#39;s just <em>unsuitable</em> as a token because it&#39;s too general.</p>
</div><h3 id="opaquetoken">OpaqueToken</h3>
<p>One solution to choosing a provider token for non-class dependencies is
to define and use an <b>OpaqueToken</b>.
The definition looks like this:</p>
<div class="code-example"><code-example language="dart" format="">import &#39;package:angular2/core.dart&#39;;

const APP_CONFIG = const OpaqueToken(&#39;app.config&#39;);
</code-example></div><p>We register the dependency provider using the <code>OpaqueToken</code> object:</p>
<div class="code-example"><code-example language="dart" format="">providers: const [
  const Provider(APP_CONFIG, useValue: heroDiConfig)]
</code-example></div><p>Now we can inject the configuration object into any constructor that needs it, with
the help of an <code>@Inject</code> annotation:</p>
<div class="code-example"><code-example language="dart" format="">AppComponent(@Inject(APP_CONFIG) Map config)
    : title = config[&#39;title&#39;];
</code-example></div><div class="l-sub-section"><p>Although the <code>Map</code> interface plays no role in dependency injection,
it supports typing of the configuration object within the class.</p>
</div><p>As an alternative to using a configuration <code>Map</code>, we can define
a custom configuration class:</p>
<div class="code-example"><header><h4>lib/app_config.dart (alternative config)</h4></header><code-example language="dart" format="">class AppConfig {
  String apiEndpoint;
  String title;
}

AppConfig heroDiConfigFactory() =&gt; new AppConfig()
  ..apiEndpoint = &#39;api.heroes.com&#39;
  ..title = &#39;Dependency Injection&#39;;
</code-example></div><p>Defining a configuration class has a few benefits. One key benefit
is strong static checking: we&#39;ll be warned early if we misspell a property
name or assign it a value of the wrong type.
The Dart <a href="https://www.dartlang.org/docs/dart-up-and-running/ch02.html#cascade">cascade notation</a> (<code>..</code>) provides a convenient means of initializing
a configuration object. </p>
<p>If we use cascades, the configuration object can&#39;t be declared <code>const</code> and
we can&#39;t use a <a href="#value-provider">value provider</a>. 
A solution is to use a <a href="#factory-provider">factory provider</a>.
We illustrate this next. We also show how to provide and inject the
configuration object in our top-level <code>AppComponent</code>:</p>
<div class="code-example"><header><h4>lib/app_component.dart (providers)</h4></header><code-example language="dart" format="">providers: const [
  Logger, UserService,
  const Provider(APP_CONFIG, useFactory: heroDiConfigFactory)]
</code-example></div><div class="code-example"><header><h4>lib/app_component.dart (ctor)</h4></header><code-example language="dart" format="">AppComponent(@Inject(APP_CONFIG) AppConfig config, this._userService)
    : title = config.title;
</code-example></div><div id="optional"></div><h2 id="optional-dependencies">Optional dependencies</h2>
<p>Our <code>HeroService</code> <em>requires</em> a <code>Logger</code>, but what if it could get by without
a logger?
We can tell Angular that the dependency is optional by annotating the 
constructor argument with <code>@Optional()</code>:</p>
<div class="code-example"><code-example language="dart" format="">HeroService(@Optional() this._logger) {
  _logger?.log(someMessage);
}
</code-example></div><p>When using <code>@Optional()</code>, our code must be prepared for a null value. If we
don&#39;t register a logger somewhere up the line, the injector will set the
value of <code>logger</code> to null.</p>
<div class="l-main-section"></div><h2 id="summary">Summary</h2>
<p>We learned the basics of Angular dependency injection in this chapter.
We can register various kinds of providers,
and we know how to ask for an injected object (such as a service) by
adding a parameter to a constructor.</p>
<p>Angular dependency injection is more capable than we&#39;ve described.
We can learn more about its advanced features, beginning with its support for
nested injectors, in the
<a href="hierarchical-dependency-injection.html">Hierarchical Dependency Injection</a> chapter.</p>
<div id="explicit-injector" class="l-main-section"></div><h2 id="appendix-working-with-injectors-directly">Appendix: Working with injectors directly</h2>
<p>We rarely work directly with an injector, but
here&#39;s an <code>InjectorComponent</code> that does.</p>
<div class="code-example"><header><h4>lib/injector_component.dart</h4></header><code-example language="dart" format="linenums">@Component(
    selector: &#39;my-injectors&#39;,
    template: &#39;&#39;&#39;
      &lt;h2&gt;Other Injections&lt;/h2&gt;
      &lt;div id=&quot;car&quot;&gt;{{car.drive()}}&lt;/div&gt;
      &lt;div id=&quot;hero&quot;&gt;{{hero.name}}&lt;/div&gt;
      &lt;div id=&quot;rodent&quot;&gt;{{rodent}}&lt;/div&gt;&#39;&#39;&#39;,
    providers: const [
      Car, Engine, Tires, heroServiceProvider, Logger])
class InjectorComponent {
  final Injector _injector;
  Car car;
  HeroService heroService;
  Hero hero;

  InjectorComponent(this._injector) {
    car = _injector.get(Car);
    heroService = _injector.get(HeroService);
    hero = heroService.getHeroes()[0];
  }

  String get rodent =&gt;
    _injector.get(ROUS, &quot;R.O.U.S.&#39;s? I don&#39;t think they exist!&quot;);
}
</code-example></div><p>An <code>Injector</code> is itself an injectable service.</p>
<p>In this example, Angular injects the component&#39;s own <code>Injector</code> into the component&#39;s constructor.
The component then asks the injected injector for the services it wants.</p>
<p>Note that the services themselves are not injected into the component.
They are retrieved by calling <code>injector.get</code>.</p>
<p>The <code>get</code> method throws an error if it can&#39;t resolve the requested service.
We can call <code>get</code> with a second parameter (the value to return if the service is not found) 
instead, which we do in one case
to retrieve a service (<code>ROUS</code>) that isn&#39;t registered with this or any ancestor injector.</p>
<div class="l-sub-section"><p>The technique we just described is an example of the
<a href="https://en.wikipedia.org/wiki/Service_locator_pattern">service locator pattern</a>.</p>
<p>We <strong>avoid</strong> this technique unless we genuinely need it.
It encourages a careless grab-bag approach such as we see here.
It&#39;s difficult to explain, understand, and test.
We can&#39;t know by inspecting the constructor what this class requires or what it will do.
It could acquire services from any ancestor component, not just its own.
We&#39;re forced to spelunk the implementation to discover what it does.</p>
<p>Framework developers may take this approach when they
must acquire services generically and dynamically.</p>
</div><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><div class="l-sub-section"><h3>Next Step</h3><a href="/docs/dart/latest/guide/template-syntax.html">Template Syntax</a></div><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></article><div class="main-footer"><nav class="background-midnight grid-fluid"><div class="c3 main-footer-branding"><div class="logo-inverse-large"></div></div><div class="c2"><h3 class="text-headline">RESOURCES</h3><ul class="text-body"><!-- TODO: (ericjim) make a libraries page to showcase all angular 2 libraries--><!--li <a href="/libraries.html">Libraries</a>--><li><a href="/about/">About</a></li><li><a href="/resources/">Books & Training</a></li><li><a href="/resources/">Tools & Libraries</a></li><li><a href="/resources/">Community</a></li><li><a href="/presskit.html">Press Kit</a></li></ul></div><div class="c2"><h3 class="text-headline">HELP</h3><ul class="text-body"><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><a href="https://github.com/angular/angular/issues"> Report Issues</a></li><li><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> Site Feedback</a></li></ul></div><div class="c2"><h3 class="text-headline">COMMUNITY</h3><ul class="text-body"><li><a href="/events.html">Events</a></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="https://twitter.com/angularjs"> Twitter</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><a href="/contribute.html"> Contribute</a></li></ul></div><div class="c2"><h3 class="text-headline">LANGUAGES</h3><ul class="text-body"><li><a href="https://angular.cn/">中文版</a></li></ul></div></nav><footer class="background-midnight"><small class="text-caption">Powered by Google ©2010-2016. Code licensed under an <a href="/license" class="text-snow">MIT-style License</a>. Documentation licensed under <a class="text-snow" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</small><a aria-label="View Style Guide" href="/docs/dart/latest/styleguide.html" title="Style Guide" class="styleguide-trigger text-snow"><span class="icon-favorite"></span></a></footer></div><!-- VENDORS --><script src="/resources/js/vendor/prettify.js"></script><script src="/resources/js/vendor/lang-basic.js"></script><script src="/resources/js/vendor/lang-dart.js"></script><script src="/resources/js/vendor/lodash.js"></script><script src="/resources/js/vendor/clipboard.min.js"></script><!-- Angular Material Dependencies --><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-aria.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.js"></script><!-- Firebase -->
<script src="https://cdn.firebase.com/js/client/2.2.4/firebase.js"></script>
<!-- AngularFire -->
<script src="https://cdn.firebase.com/libs/angularfire/1.2.0/angularfire.min.js"></script>
<!-- Angular.io Site JS --><script src="/resources/js/site.js"></script><script src="/resources/js/util.js"></script><script src="/resources/js/controllers/app-controller.js"></script><script src="/resources/js/controllers/resources-controller.js"></script><script src="/resources/js/directives/cheatsheet.js"></script><script src="/resources/js/directives/api-list.js"></script><script src="/resources/js/directives/bio.js"></script><script src="/resources/js/directives/bold.js"></script><script src="/resources/js/directives/announcement-bar.js"></script><script src="/resources/js/directives/code.js"></script><script src="/resources/js/directives/copy.js"></script><script src="/resources/js/directives/code-tabs.js"></script><script src="/resources/js/directives/code-pane.js"></script><script src="/resources/js/directives/code-example.js"></script><script src="/resources/js/directives/if-docs.js"></script><script src="/resources/js/directives/live-example.js"></script><script src="/resources/js/directives/ngio-ex-path.js"></script><script src="/resources/js/directives/scroll-y-offset-element.js"></script><!-- GA --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-8594346-15', 'auto');
ga('send', 'pageview')

</script><!-- SWIFTYPE --><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

_st('install','VsuU7kH5Hnnj9tfyNvfK');
</script><!-- Google Feedback --><script src="//www.gstatic.com/feedback/api.js" type="text/javascript"></script><!-- Twitter Widget --><script>(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}})(document,"script","twitter-wjs");</script></body></html>