<!DOCTYPE html><html lang="en" ng-app="angularIOApp" itemscope itemtype="http://schema.org/Framework"><!-- template: public/docs/_layout--><head><title>Testing - ts</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta name="keywords" content="Angular, AngularJS, AngularDart, Javscript, Dart, Framework, JavaScript MVC, Google"/><meta name="robots" content="all"/><meta name="referrer" content="origin"/><meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Angular 2"/><meta property="og:image" content="/resources/images/logos/standard/shield-large.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="184"/><meta property="og:image:height" content="200"/><meta property="og:description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="name" content="Angular 2"/><meta itemprop="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="image" content="https://angular.io/resources/images/logos/standard/shield-large.png"/><link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico"/><link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,300,500,400italic,700" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/><link rel="stylesheet" href="/resources/css/vendor/icomoon/style.css"/><link rel="stylesheet" href="/resources/css/vendor/animate.css"/><link rel="stylesheet" href="/resources/css/main.css"/><!-- MOBILE ICONS -->
<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/resources/images/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/resources/images/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-194x194.png" sizes="194x194">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/resources/images/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/resources/images/favicons/manifest.json"></head><body ng-controller="AppCtrl as appCtrl" class="l-offset-nav l-offset-side-nav"><nav scroll-y-offset-element="scroll-y-offset-element" class="main-nav l-pinned-top l-layer-5"><h1><a href="/" md-button>Angular <sup>by Google</sup></a></h1><button aria-label="View Menu" ng-click="appCtrl.toggleMainMenu($event)" md-button="md-button" class="main-nav-button main-nav-mobile-trigger l-right">Site Menu <span class="icon icon-arrow-drop-down"></span></button><ul ng-class="appCtrl.showMainNav ? 'is-visible' : ''"><li class="l-left"><a class="main-nav-button" href="/features.html" md-button>Features</a></li><li class="l-left"><a class="main-nav-button" href="/docs/ts/latest/" md-button>Docs</a></li><li class="l-left"><a class="main-nav-button" href="/events.html" md-button>Events</a></li><li class="l-left"><a class="main-nav-button" href="/news.html" md-button>News</a></li><li class="l-right"><a class="main-nav-button" href="/docs/ts/latest/quickstart.html" md-button>Get Started</a></li></ul></nav><!-- Include this file ONLY when current.path[2] is defined--><nav ng-class="appCtrl.showDocsNav ? 'is-visible' : ''" class="sidenav l-pinned-left l-layer-4 l-offset-nav"><!-- SEARCH BAR--><header class="sidenav-search st-input-wrapper"><form class="st-input-inner"><label for="search-io" class="is-hidden">Search Docs</label><input type="search" id="search-io" placeholder="SEARCH DOCS..."/></form><button aria-label="View Docs Menu" ng-click="appCtrl.toggleDocsMenu($event)" md-button="md-button" class="mobile-trigger button">Docs <span class="icon icon-arrow-drop-down"></span></button></header><ul class="sidenav-links"><li class="sidenav-section no-border"><a href="/docs/ts/latest/" class="nav-title">Docs Home</a></li><!-- CORE DOCUMENTATION--><li class="sidenav-section-divider"><h3>Core Documentation</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/quickstart.html" title="Get up and running with Angular 2" class="nav-title ">Quickstart</a></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/" title="How to read and use this documentation" class="nav-title is-parent ">Guide<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/" title="How to read and use this documentation">1. Overview</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/architecture.html" title="The basic building blocks of Angular 2 applications">2. Architecture</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/displaying-data.html" title="Interpolation and other forms of property binding help us show app data in the UI.">3. Displaying Data</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/user-input.html" title="User input triggers DOM events. We listen to those events with event bindings that funnel updated values back into our components and models.">4. User Input</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/forms.html" title="A form creates a cohesive, effective, and compelling data entry experience. An Angular form coordinates a set of data-bound user controls, tracks changes, validates input, and presents errors.">5. Forms</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/dependency-injection.html" title="Angular's dependency injection system creates and delivers dependent services &quot;just-in-time&quot;.">6. Dependency Injection</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/template-syntax.html" title="Learn how to write templates that display data and consume user events with the help of data binding.">7. Template Syntax</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/cheatsheet.html" title="A quick guide to Angular syntax. (Content is provisional and may change.)">8. Angular Cheat Sheet</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/style-guide.html" title="Write Angular 2 with style.">9. Style Guide</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/glossary.html" title="Brief definitions of the most important words in the Angular 2 vocabulary">10. Glossary</a></li></ul></div></li><li class="sidenav-section no-border"><a href="/docs/ts/latest/api/" title="API Preview" class="nav-title ">API Reference</a></li><!-- ADVANCED DOCUMENATION--><li class="sidenav-section-divider"><h3>Additional Documentation</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/tutorial/" title="The Tour of Heroes tutorial takes us through the steps of creating an Angular application in TypeScript." class="nav-title is-parent ">Tutorial<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/" title="The Tour of Heroes tutorial takes us through the steps of creating an Angular application in TypeScript.">1. Introduction</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt1.html" title="We build a simple hero editor">2. The Hero Editor</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt2.html" title="We build a master/detail page with a list of heroes">3. Master/Detail</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt3.html" title="We refactor the master/detail view into separate components">4. Multiple Components</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt4.html" title="We create a reusable service to manage our hero data calls">5. Services</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt5.html" title="We add the Angular Component Router and learn to navigate among the views">6. Routing</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt6.html" title="We convert our service and components to use Angular's HTTP service">7. HTTP</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/ngmodule.html" title="Define application modules with @NgModule" class="nav-title is-parent is-selected">Advanced Documentation<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/ngmodule.html" title="Define application modules with @NgModule">Angular Modules (NgModule)</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/animations.html" title="A guide to Angular's animation system.">Animations</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/attribute-directives.html" title="Attribute directives attach behavior to elements.">Attribute Directives</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/browser-support.html" title="Browser support and polyfills guide.">Browser support</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/component-styles.html" title="Learn how to apply CSS styles to components.">Component Styles</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/hierarchical-dependency-injection.html" title="Angular's hierarchical dependency injection system supports nested injectors in parallel with the component tree.">Hierarchical Injectors</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/server-communication.html" title="Talk to a remote server with an HTTP Client.">HTTP Client</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/lifecycle-hooks.html" title="Angular calls lifecycle hook methods on directives and components as it creates, changes, and destroys them.">Lifecycle Hooks</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/npm-packages.html" title="Recommended npm packages, and how to specify package dependencies">Npm Packages</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/pipes.html" title="Pipes transform displayed values within a template.">Pipes</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/router.html" title="Discover the basics of screen navigation with the Angular 2 Router.">Routing &amp; Navigation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/security.html" title="Developing for content security in Angular applications">Security</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/structural-directives.html" title="Angular has a powerful template engine that lets us easily manipulate the DOM structure of our elements.">Structural Directives</a></li><li class="nav-list-item is-selected"><a href="/docs/ts/latest/guide/testing.html" title="Techniques and practices for testing an Angular 2 app">Testing</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/typescript-configuration.html" title="TypeScript configuration for Angular 2 developers">TypeScript Configuration</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/upgrade.html" title="Angular 1 applications can be incrementally upgraded to Angular 2.">Upgrading from 1.x</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/webpack.html" title="Create your Angular 2 applications with a Webpack based tooling">Webpack: an introduction</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/cookbook/" title="A collection of recipes for common Angular application scenarios" class="nav-title is-parent ">Cookbook<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/" title="A collection of recipes for common Angular application scenarios">Overview</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/aot-compiler.html" title="Learn how to use Ahead-of-time compilation">Ahead-of-Time Compilation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/a1-a2-quick-reference.html" title="Learn how Angular 1 concepts and techniques map to Angular 2">Angular 1 to 2 Quick Ref</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ngmodule-faq.html" title="Answers to frequently asked questions about @NgModule">Angular Module FAQs</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-communication.html" title="Share information between different directives and components">Component Interaction</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-relative-paths.html" title="Use relative URLs for component templates and styles.">Component-relative Paths</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dependency-injection.html" title="Techniques for Dependency Injection">Dependency Injection</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-form.html" title="Render dynamic forms with FormGroup">Dynamic Forms</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/form-validation.html" title="Validate user's form entries">Form Validation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/rc4-to-rc5.html" title="Migrate your RC4 app to RC5 in minutes.">RC4 to RC5 Migration</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/set-document-title.html" title="Setting the document or window title using the Title service.">Set the Document Title</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ts-to-js.html" title="Convert Angular 2 TypeScript examples into ES5 JavaScript">TypeScript to JavaScript</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/visual-studio-2015.html" title="Use Visual Studio 2015 with the QuickStart files">Visual Studio 2015 QuickStart</a></li></ul></div></li></ul><!-- DROPDOWN BUTTON --><nav class="dropdown"><button aria-label="Select a version of Angular" md-button="md-button" ng-click="appCtrl.toggleVersionMenu($event)" class="dropdown-button">Angular 2 for TypeScript  <span class="icon icon-arrow-drop-down"></span></button><div ng-click="appCtrl.toggleVersionMenu($event)" ng-show="appCtrl.showMenu" class="overlay ng-hide"></div><!-- DROPDOWN MENU --><ul ng-class="appCtrl.showMenu ? 'is-visible' : ''" class="dropdown-menu"><li><a href="/docs/ts/latest/guide/testing.html" md-button>Angular 2 for TypeScript </a></li><li><a href="/docs/js/latest/guide/testing.html" md-button>Angular 2 for JavaScript </a></li><li><a href="/docs/dart/latest/guide/testing.html" md-button>Angular 2 for Dart </a></li></ul></nav></nav><script>// Could put in appCtrl but only needed here and clear here
(function scrollToSelectedLink() {
  var sideNav = document.getElementsByClassName('sidenav')[0];
  var link = sideNav.getElementsByClassName('is-selected')[0];
  if(link && link.offsetTop > window.innerHeight){
    sideNav.scrollTop = link.offsetTop - (window.innerHeight/2);
    //alert("offsetTop: " + link.offsetTop + " side-nav top is " + sideNav.scrollTop);
  }
})()</script><!-- template: public/_includes/_hero--><header class="hero background-sky"><h1 class="hero-title ">Testing</h1><!--CLEAR FLOAT ELEMENTS--><div class="clear"></div></header><div class="banner"><p class="text-body">Techniques and practices for testing an Angular 2 app</p></div><article class="l-content-small grid-fluid docs-content"><script>function why(id, backTo) {
  var id = "#"+id;
  var el = document.querySelector(id);
  el.hidden=el.hidden=!el.hidden;

  if (el.hidden && backTo){
    // the next line is required to work around a bug in WebKit (Chrome / Safari)
    location.href = "#";
    location.href =  "#" + backTo;
  }
}</script><script>function verbose(isVerbose) {
  isVerbose = !! isVerbose;
  var el = document.querySelector('button.verbose.off');
  el.style.display = isVerbose ? 'block' : 'none';
  var el = document.querySelector('button.verbose.on');
  el.style.display = isVerbose ? 'none' : 'block';

  CCSStylesheetRuleStyle('main','.l-verbose-section', 'display',
    isVerbose ? 'block' : 'none');
}
</script><script>function CCSStylesheetRuleStyle(stylesheet, selectorText, style, value){
  /* returns the value of the element style of the rule in the stylesheet
  *  If no value is given, reads the value
  *  If value is given, the value is changed and returned
  *  If '' (empty string) is given, erases the value.
  *  The browser will apply the default one
  *
  * string stylesheet: part of the .css name to be recognized, e.g. 'default'
  * string selectorText: css selector, e.g. '#myId', '.myClass', 'thead td'
  * string style: camelCase element style, e.g. 'fontSize'
  * string value optional : the new value
  */
  var CCSstyle = undefined, rules, sheet;
  for(var m in document.styleSheets){
    sheet = document.styleSheets[m];
    if(sheet.href && sheet.href.indexOf(stylesheet) != -1){
    rules = sheet[document.all ? 'rules' : 'cssRules'];
    for(var n in rules){
      console.log(rules[n].selectorText);
      if(rules[n].selectorText == selectorText){
        CCSstyle = rules[n].style;
        break;
      }
    }
    break;
    }
  }
  if(value == undefined)
    return CCSstyle[style]
  else
    return CCSstyle[style] = value
}
</script><p>This chapter offers tips and techniques for testing Angular applications. 
Along the way you will learn some general testing principles and techniques but the focus is on
Angular testing.</p>
<a id="top"></a><h1 id="contents">Contents</h1>
<ul>
<li><a href="#testing-101">Introduction to Angular Testing</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#1st-karma-test">The first karma test</a></li>
<li><a href="#atp-intro">The Angular Testing Platform (ATP) </a></li>
<li><a href="#sample-app">The sample application and its tests</a></li>
<li><a href="#simple-component-test">A simple component test</a></li>
<li><a href="#component-with-dependency">Test a component with a service dependency</a></li>
<li><a href="#component-with-async-service">Test a component with an async service</a></li>
<li><a href="#component-with-external-template">Test a component with an external template</a></li>
<li><a href="#component-with-inputs-output">Test a component with inputs and outputs</a></li>
<li><a href="#component-inside-test-host">Test a component inside a test host component</a></li>
<li><a href="#routed-component">Test a routed component</a>  </li>
<li><a href="#testing-without-atp" title="Testing without the Angular Testing Platform">Isolated tests</a></li>
<li><a href="#atp-api"><em>TestBed</em> API</a></li>
<li><a href="#faq" title="Frequently asked questions">FAQ</a></li>
</ul>
<p>It’s a big agenda. Fortunately, you can learn a little bit at a time and put each lesson to use.</p>
<h1 id="live-examples">Live examples</h1>
<p>The chapter sample code is available as live examples for inspection, experiment, and download.</p>
<ul>
<li><live-example>The sample application</live-example></li>
<li><live-example plnkr="1st-specs">The first spec</live-example></li>
<li><live-example plnkr="app-specs">The complete application specs</live-example></li>
<li><live-example plnkr="bag-specs">A grab bag of demonstration specs</live-example></li>
</ul>
<a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="testing-101"></a><h1 id="introduction-to-angular-testing">Introduction to Angular Testing</h1>
<p>You write tests to explore and confirm the behavior of the application.</p>
<ol>
<li><p>They <strong>guard</strong> against changes that break existing code (“regressions”).</p>
</li>
<li><p>They <strong>clarify</strong> what the code does both when used as intended and when faced with deviant conditions.</p>
</li>
<li><p>They <strong>reveal</strong> mistakes in design and implementation. 
Tests shine a harsh light on the code from many angles. 
When a part of the application seems hard to test, the root cause is often a design flaw, 
something to cure now rather than later when it becomes expensive to fix.</p>
</li>
</ol>
<p>This chapter assumes that you know something about testing. Don&#39;t worry if you don&#39;t. 
There are plenty of books and online resources to get up to speed.</p>
<!-- TODO
:marked
## Learn more
Learn more about basic Jasmine testing here
[Resources TBD](./#)
-->
<h2 id="tools-and-technologies">Tools and Technologies</h2>
<p>You can write and run Angular tests with a variety of tools and technologies. 
This chapter describes specific choices that are known to work well.</p>
<table width="100%"><col width="20%"><col width="80%"><tr><th>Technology</th><th>Purpose</th></tr><tr><td style="vertical-align: top">Jasmine</td><td><p>The <a href="http://jasmine.github.io/2.4/introduction.html">Jasmine test framework</a>.
provides everything needed to write basic tests. 
It ships with an HTML test runner that executes tests in the browser.</p>
</td></tr><tr><td style="vertical-align: top">Angular Testing Platform</td><td><p>The Angular Testing Platform creates a test environment and harness
for the application code under test. 
Use it to condition and control parts of the application as they 
interact <em>within</em> the Angular environment.</p>
</td></tr><tr><td style="vertical-align: top">Karma</td><td><p>The <a href="https://karma-runner.github.io/1.0/index.html">karma test runner</a>
is ideal for writing and running tests while developing the application. 
It can be an integral part of the application build process.
This chapter describes how to setup and run tests with karma.</p>
</td></tr><tr><td style="vertical-align: top">Protractor</td><td><p>Use protractor to write and run <em>end-to-end</em> (e2e) tests.
End-to-end tests explore the application <em>as users experience it</em>.
In e2e testing, one process runs the real application
and a second process runs protractor tests that simulate user behavior 
and assert that the application responds in the browser as expected.</p>
</td></tr></table><div class="l-hr"></div><a id="setup"></a><h1 id="setup">Setup</h1>
<p>Many think writing tests is fun. 
Few enjoy setting up the test environment.
To get to the fun as quickly as possible, 
the deep details of setup appear later in the chapter (<em>forthcoming</em>).
A bare minimum of discussion plus the downloadable source code must suffice for now.</p>
<p>There are two fast paths to getting started.</p>
<ol>
<li><p>Start a new project following the instructions in the 
<a href="https://github.com/angular/quickstart/blob/master/README.md">QuickStart github repository</a>.</p>
</li>
<li><p>Start a new project with the 
<a href="https://github.com/angular/angular-cli/blob/master/README.md">Angular CLI</a>.</p>
</li>
</ol>
<p>Both approaches install <strong>npm packages, files, and scripts</strong> pre-configured for applications
built in their respective modalities. 
Their artifacts and procedures differ slightly but their essentials are the same 
and there are no differences in the test code.</p>
<p>In this chapter, the application and its tests are based on the QuickStart repo.</p>
<div class="alert is-helpful"><p>If youur application was based on the QuickStart repository,
you can skip the rest of this section and get on with your first test.
The QuickStart repo provides all necessary setup.</p>
</div><p>Here&#39;s brief description of the setup files.</p>
<table width="100%"><col width="20%"><col width="80%"><tr><th>File</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>karma.conf.js</code></td><td><p>The karma configuration file that specifies which plug-ins to use, 
which application and test files to load, which browser(s) to use,
and how to report test results.</p>
<p>It loads three other setup files:</p>
<ul>
<li><code>systemjs.config.js</code> </li>
<li><code>systemjs.config.extras.js</code></li>
<li><code>karma-test-shim.js</code></li>
</ul>
</td></tr><tr><td style="vertical-align: top"><code>karma-test-shim.js</code></td><td><p>This shim prepares karma specifically for the Angular test environment 
and launches karma itself. 
It loads the <code>systemjs.config.js</code> file as part of that process.</p>
</td></tr><tr><td style="vertical-align: top"><code>systemjs.config.js</code></td><td><p><a href="https://github.com/systemjs/systemjs/blob/master/README.md">SystemJS</a> 
loads the application and test modules.
This script tells SystemJS where to find the module files and how to load them.
It&#39;s the same version of the file used by QuickStart-based applications.</p>
</td></tr><tr><td style="vertical-align: top"><code>systemjs.config.extras.js</code></td><td><p>An optional file that supplements the SystemJS configuration in <code>systemjs.config.js</code> with
configuration for the specific needs of the application itself.</p>
<p>A stock <code>systemjs.config.js</code> can&#39;t anticipate those needs. 
You fill the gaps here.</p>
<p>The sample version for this chapter adds the <strong>model barrel</strong>
to the SystemJs <code>packages</code> configuration.</p>
</td></tr><tr><td colspan="2"> <div class="code-example"><header><h4>systemjs.config.extras.js</h4></header><code-example language="js" format="">/** App specific SystemJS configuration */
System.config({
  packages: {
    // barrels
    &#39;app/model&#39;: {main:&#39;index.js&#39;, defaultExtension:&#39;js&#39;},
    &#39;app/model/testing&#39;: {main:&#39;index.js&#39;, defaultExtension:&#39;js&#39;}
  }
});
</code-example></div></td></tr></table><h3 id="npm-packages">npm packages</h3>
<p>The sample tests are written to run in Jasmine and karma.
The two &quot;fast path&quot; setups added the appropriate Jasmine and karma npm packages to the 
<code>devDependencies</code> section of the <code>package.json</code>.
They were installed when you ran <code>npm install</code>.</p>
<div class="l-hr"></div><a id="1st-karma-test"></a><h1 id="the-first-karma-test">The first karma test</h1>
<p>Start with a simple test to make sure the setup works properly.</p>
<p>Create a new file called <code>1st.spec.ts</code> in the application root folder, <code>app/</code></p>
<div class="alert is-important"><p>Tests written in Jasmine are called <em>specs</em> . 
<strong>The filename extension must be <code>.spec.ts</code></strong>, 
the convention adhered to by  <code>karma.conf.js</code> and other tooling.</p>
</div><p><strong>Put spec files somewhere within the <code>app/</code> folder.</strong>
The <code>karma.conf.js</code> tells karma to look for spec files there,
for reasons explained <a href="#spec-file-location">below</a>.</p>
<p>Add the following code to <code>app/1st.spec.ts</code>.</p>
<div class="code-example"><header><h4>app/1st.spec.ts</h4></header><code-example language="ts" format="">describe(&#39;1st tests&#39;, () =&gt; {
  it(&#39;true is true&#39;, () =&gt; expect(true).toBe(true));
});
</code-example></div><h2 id="run-karma">Run karma</h2>
<p>Compile and run it in karma from the command line.</p>
<div class="l-sub-section"><p>The QuickStart repo adds the following command to the <code>scripts</code> section in  <code>package.json</code>.</p>
<code-example format="." language="bash">"test": "tsc && concurrently \"tsc -w\" \"karma start karma.conf.js\"",</code-example><p>Add that to your <code>package.json</code> if it&#39;s not there already.</p>
</div><p>Open a terminal or command window and enter</p>
<code-example format="." language="bash">npm test</code-example><p>The command compiles the application and test code a first time. 
If the compile fails, the command aborts.</p>
<p>If it succeeds, the command re-compiles (this time in watch mode) in one process
and starts karma in another.
Both processes watch pertinent files and re-run when they detect changes.</p>
<p>After a few moments, karma opens a browser ...</p>
<figure class="image-display"><img src="/resources/images/devguide/testing/karma-browser.png" style="width:400px" alt="Karma browser"></figure><p>... and starts writing to the console.</p>
<p>Hide (don&#39;t close!) the browser and focus on the console output which should look something like this.</p>
<code-example format="." language="bash">> npm test
> tsc && concurrently "tsc -w" "karma start karma.conf.js"

[0] 1:37:03 PM - Compilation complete. Watching for file changes.
[1] 24 07 2016 13:37:09.310:WARN [karma]: No captured browser, open http://localhost:9876/
[1] 24 07 2016 13:37:09.361:INFO [karma]: Karma v0.13.22 server started at http://localhost:9876/
[1] 24 07 2016 13:37:09.370:INFO [launcher]: Starting browser Chrome
[1] 24 07 2016 13:37:10.974:INFO [Chrome 51.0.2704]: Connected on socket /#Cf6A5PkvMzjbbtn1AAAA with id 24600087
[1] Chrome 51.0.2704: Executed 0 of 0 SUCCESS  
    Chrome 51.0.2704: Executed 1 of 1 SUCCESS
SUCCESS (0.005 secs / 0.005 secs)
</code-example><p>Both the compiler and karma continue to run. The compiler output is preceeded by <code>[0]</code>; 
the karma output by <code>[1]</code>.</p>
<p>Change the expectation from <code>true</code> to <code>false</code>.</p>
<p>The <em>compiler</em> watcher detects the change and recompiles.</p>
<code-example format="." language="bash">[0] 1:49:21 PM - File change detected. Starting incremental compilation...
[0] 1:49:25 PM - Compilation complete. Watching for file changes.
</code-example><p>The <em>karma</em> watcher detects the change to the compilation output and re-runs the test.</p>
<code-example format="." language="bash">[1] Chrome 51.0.2704: Executed 0 of 1 SUCCESS
    Chrome 51.0.2704 1st tests true is true FAILED
[1] Expected false to equal true.
[1] Chrome 51.0.2704: Executed 1 of 1 (1 FAILED) (0.005 secs / 0.005 secs)
</code-example><p>It failed of course.</p>
<p>Restore the expectation from <code>false</code> back to <code>true</code>.
Both processes detect the change, re-run, and karma reports complete success.</p>
<div class="alert is-helpful"><p>The console log can be quite long. Keep your eye on the last line.
It says <code>SUCCESS</code> when all is well.</p>
<p>If it says <code>FAILED</code>, scroll up to look for the error or, if that&#39;s too painful,
pipe the console output to a file and inspect with your favorite editor.</p>
<code-example format="." language="json">npm test > spec-output.txt
</code-example></div><h2 id="test-debugging">Test debugging</h2>
<p>Debug specs in the browser in the same way you debug an application.</p>
<ul>
<li>Reveal the karma browser window (hidden earlier).</li>
<li>Open the browser&#39;s “Developer Tools” (F12 or Ctrl-Shift-I).</li>
<li>Pick the “sources” section</li>
<li>Open the <code>1st.spec.ts</code> test file (Ctrl-P, then start typing the name of the file).</li>
<li>Set a breakpoint in the test</li>
<li>Refresh the browser … and it stops at the breakpoint.</li>
</ul>
<figure class="image-display"><img src="/resources/images/devguide/testing/karma-1st-spec-debug.png" style="width:700px" alt="Karma debugging"></figure><a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="atp-intro"></a><h1 id="the-angular-testing-platform-atp-">The Angular Testing Platform (ATP)</h1>
<p>Many tests explore how applications classes interact with Angular and the DOM while under Angular&#39;s control.</p>
<p>Such tests are easy to write with the help of the <em>Angular Testing Platform</em> (ATP)
which consists of the <code>TestBed</code> class and some helper functions.</p>
<p>Tests written with the <em>Angular Testing Platform</em> are the main focus of this chapter. 
But they are not the only tests you should write.  </p>
<h3 id="isolated-unit-tests">Isolated unit tests</h3>
<p>You can and should write <a href="#testing-without-atp" title="Testing without the Angular Testing Platform">isolated unit tests</a> 
for components, directives, pipes, and services.
Isolated unit tests examine an instance of a class all by itself without 
any dependence on Angular or any injected values. 
The tester creates a test instance of the class with new, supplying fake constructor parameters as needed, and
then probes the test instance API surface.</p>
<p>Isolated tests don&#39;t reveal how the class interacts with Angular. 
In particular, they can&#39;t reveal how a component class interacts with its own template or with other components.</p>
<p>Those tests require the Angular Testing Platform.</p>
<h3 id="testing-with-the-_-angular-testing-platform_">Testing with the <em> Angular Testing Platform</em></h3>
<p>The  <em>Angular Testing Platform</em> consists of the <code>TestBed</code> class and some helper functions from <code>@angular/core/testing</code>.</p>
<div class="alert is-important"><p>The <em>TestBed</em> is officially <em>experimental</em> and thus subject to change.
Consult the <a href="../api/core/testing/index/TestBed-class.html">API reference</a> for the latest status.</p>
</div><p>The <code>TestBed</code> creates an Angular test module &mdash; an <code>@NgModule</code> class &mdash;
that you configure to produce the module environment for the class you want to test. 
You tell the <code>TestBed</code> to create an instance of the test component and probe that instance with tests.</p>
<p>That&#39;s the <code>TestBed</code> in a nutshell.</p>
<p>In practice, you work with the static methods of the <code>TestBed</code> class. 
These static methods create and update a fresh hidden <code>TestBed</code> instance before each Jasmine <code>it</code>.</p>
<div class="l-sub-section"><p>You can access that hidden instance anytime by calling <code>getTestBed()</code>;</p>
</div><p>This <code>TestBed</code> instance comes pre-configured with a baseline of default providers and declarables (components, directives, and pipes)
that almost everyone needs. 
This chapter tests a browser application so the default includes the <code>CommonModule</code> declarables from <code>@angular/common</code>
and the <code>BrowserModule</code> providers (some of them mocked) from <code>@angular/platform-browser</code>.</p>
<p>You refine the default test module configuration with application and test specifics 
so that it can produce an instance of the test component in the Angular environment suitable for your tests.</p>
<p>Start by calling <code>TestBed.configureTestingModule</code> with an object that looks like <code>@NgModule</code> metadata.
This object defines additional imports, declarations, providers and schemas.</p>
<p>After configuring the <code>TestBed</code>, tell it to create an instance of the test component and the test fixture
you&#39;ll need to inspect and control the component&#39;s immediate environment.</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (simplified)</h4></header><code-example language="ts" format="">beforeEach(() =&gt; {

  // refine the test module by declaring the test component
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ],
  });

  // create component and test fixture
  fixture = TestBed.createComponent(BannerComponent);

  // get test component from the fixture
  comp = fixture.componentInstance;
});
</code-example></div><p>Angular tests can interact with the HTML in the test DOM, 
simulate user activity, tell Angular to perform specific task (such as change detection), 
and see the effects of these actions both in the test component and in the test DOM.</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (simplified)</h4></header><code-example language="ts" format="">it(&#39;should display original title&#39;, () =&gt; {

  // trigger data binding to update the view
  fixture.detectChanges();

  // find the title element in the DOM using a CSS selector
  el = fixture.debugElement.query(By.css(&#39;h1&#39;));

  // confirm the element&#39;s content
  expect(el.nativeElement.textContent).toContain(comp.title);
});
</code-example></div><p>A comprehensive review of the <em>TestBed</em> API appears <a href="#atp-api">later in the chapter</a>.
Let&#39;s dive right into Angular testing, starting with with the components of a sample application.</p>
<a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="sample-app"></a><h1 id="the-sample-application-and-its-tests">The sample application and its tests</h1>
<p>This chapter tests a cut-down version of the <em>Tour of Heroes</em> <a href="../tutorial">tutorial app</a>.</p>
<p>The following live example shows how it works and provides the complete source code.</p>
<live-example embedded img="devguide/testing/app-plunker.png"></live-example>
<br><br><p>The following live example runs all the tests of this application
inside the browser, using the Jasmine Test Runner instead of karma.</p>
<p>It includes the tests discussed in this chapter and additional tests for you to explore.
This live example contains both application and test code. 
It is large and can take several minutes to start. Please be patient.</p>
<live-example plnkr="app-specs" embedded img="devguide/testing/app-specs-plunker.png"></live-example><a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="simple-component-test"></a><h1 id="test-a-component">Test a component</h1>
<p>The top of the screen displays application title, presented by the <code>BannerComponent</code> in <code>app/banner.component.ts</code>.</p>
<div class="code-example"><header><h4>app/banner.component.ts</h4></header><code-example language="ts" format="">import { Component }   from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-banner&#39;,
  template: &#39;&lt;h1&gt;{{title}}&lt;/h1&gt;&#39;
})
export class BannerComponent {
  title = &#39;Test Tour of Heroes&#39;;
}
</code-example></div><p><code>BannerComponent</code> has an inline template and an interpolation binding, about as simple as it gets.
Probably too simple to be worth testing in real life but perfect for a first encounter with the <code>TestBed</code>.</p>
<p>The corresponding <code>app/banner-component.spec.ts</code> sits in the same folder as the component,
for reasons explained <a href="#q-spec-file-location">here</a>;</p>
<p>Start with ES6 import statements to get access to symbols referenced in the spec.</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (imports)</h4></header><code-example language="ts" format="">import { ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;
import { By }              from &#39;@angular/platform-browser&#39;;
import { DebugElement }    from &#39;@angular/core&#39;;

import { BannerComponent } from &#39;./banner.component&#39;;
</code-example></div><p>Here&#39;s the setup for the tests followed by observations about the <code>beforeEach</code>:</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (imports)</h4></header><code-example language="ts" format="">let comp:    BannerComponent;
let fixture: ComponentFixture&lt;BannerComponent&gt;;
let el:      DebugElement;

describe(&#39;BannerComponent&#39;, () =&gt; {
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ], // declare the test component
    });

    fixture = TestBed.createComponent(BannerComponent);

    comp = fixture.componentInstance; // BannerComponent test instance

    // get title DebugElement by element name
    el = fixture.debugElement.query(By.css(&#39;h1&#39;));
  });
});
</code-example></div><p><code>TestBed.configureTestingModule</code> takes an <code>@NgModule</code>-like metadata object.
This one simply declares the component to test, <code>BannerComponent</code>.</p>
<p>It lacks <code>imports</code> because (a) it extends the default test module configuration which 
already has what <code>BannerComponent</code> needs
and (b) <code>BannerComponent</code> doesn&#39;t interact with any other components.</p>
<p>The configuration could have imported <code>AppModule</code> (which declares <code>BannerComponent</code>).
But that would lead to tons more configuration in order to support the other components within <code>AppModule</code> 
that have nothing to do with <code>BannerComponent</code>.</p>
<p><code>TestBed.createComponent</code> creates an instance of <code>BannerComponent</code> to test.
The method returns a <code>ComponentFixture</code>, a handle on the test environment surrounding the created component.
The fixture provides access to the component instance itself and 
to the <code>DebugElement</code> which is a handle on the component&#39;s DOM element.</p>
<p>Query the <code>DebugElement</code> by CSS selector for the <code>&lt;h1&gt;</code> sub-element that holds the actual title.</p>
<h3 id="_createcomponent_-closes-configuration"><em>createComponent</em> closes configuration</h3>
<p><code>TestBed.createComponent</code> closes the current <code>TestBed</code> instance to further configuration.
  You cannot call any more <code>TestBed</code> configuration methods, not <code>configureTestModule</code> 
  nor any of the <code>override...</code> methods. The <code>TestBed</code> throws an error if you try.</p>
<div class="alert is-important"><p>Do not configure the <code>TestBed</code> after calling <code>createComponent</code>. </p>
</div><h3 id="the-tests">The tests</h3>
<p>Jasmine runs this <code>beforeEach</code> before each test of which there are two</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (tests)</h4></header><code-example language="ts" format="">it(&#39;should display original title&#39;, () =&gt; {
  fixture.detectChanges(); // trigger data binding
  expect(el.nativeElement.textContent).toContain(comp.title);
});

it(&#39;should display a different test title&#39;, () =&gt; {
  comp.title = &#39;Test Title&#39;;
  fixture.detectChanges(); // trigger data binding
  expect(el.nativeElement.textContent).toContain(&#39;Test Title&#39;);
});
</code-example></div><p>These tests ask the <code>DebugElement</code> for the native HTML element to satisfy their expectations.</p>
<a id="fixture-detect-changes"></a><h3 id="_detectchanges_-angular-change-detection-under-test"><em>detectChanges</em>: Angular change detection under test</h3>
<p>Each test tells Angular when to perform change detection by calling <code>fixture.detectChanges()</code>.
The first test does so immediately, triggering data binding and propagation of the <code>title</code> property
to the DOM element.</p>
<p>The second test changes the component&#39;s <code>title</code> property <em>and only then</em> calls <code>fixture.detectChanges()</code>;
the new value appears in the DOM element.</p>
<p>In production, change detection kicks in automatically
when Angular creates a component or the user enters a keystroke or
an asynchronous activity (e.g., AJAX) completes.</p>
<p>The <code>TestBed.createComponent</code> does <em>not</em> trigger change detection.
The fixture does not automatically push the component&#39;s <code>title</code> property value into the data bound element,
a fact demonstrated in the following test:</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (no detectChanges)</h4></header><code-example language="ts" format="">it(&#39;no title in the DOM until manually call `detectChanges`&#39;, () =&gt; {
  expect(el.nativeElement.textContent).toEqual(&#39;&#39;);
});
</code-example></div><p>This behavior (or lack of it) is intentional.
It gives the tester an opportunity to investigate the state of
the component <em>before Angular initiates data binding or calls lifecycle hooks</em>.</p>
<a id="automatic-change-detection"></a><h3 id="automatic-change-detection">Automatic change detection</h3>
<p>Some testers prefer that the Angular test environment run change detection automatically.
That&#39;s possible by configuring the <code>TestBed</code> with the <em>AutoDetect</em> provider:</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (AutoDetect)</h4></header><code-example language="ts" format="">fixture = TestBed.configureTestingModule({
  declarations: [ BannerComponent ],
  providers: [
    { provide: ComponentFixtureAutoDetect,
      useValue: true }
  ]
})
</code-example></div><p>Here are three tests that illustrate how <em>auto-detect</em> works.</p>
<div class="code-example"><header><h4>app/banner.component.spec.ts (AutoDetect Tests)</h4></header><code-example language="ts" format="">it(&#39;should display original title&#39;, () =&gt; {
  // Hooray! No `fixture.detectChanges()` needed
  expect(el.nativeElement.textContent).toContain(comp.title);
});

it(&#39;should still see original title after comp.title change&#39;, () =&gt; {
  const oldTitle = comp.title;
  comp.title = &#39;Test Title&#39;;
  // Displayed title is old because Angular didn&#39;t hear the change :(
  expect(el.nativeElement.textContent).toContain(oldTitle);
});

it(&#39;should display updated title after detectChanges&#39;, () =&gt; {
  comp.title = &#39;Test Title&#39;;
  fixture.detectChanges(); // detect changes explicitly
  expect(el.nativeElement.textContent).toContain(comp.title);
});
</code-example></div><p>The first test shows the benefit of automatic change detection.</p>
<p>The second and third test remind us that Angular does <em>not</em> know about changes to component property
values unless Angular itself (or some asynchronous process) makes the change.
This is as true in production as it is in test. </p>
<p>In production, external forces rarely change component properties like this,
whereas these kinds of probing changes are typical in unit tests.
The tester will have to call <code>fixture.detectChanges()</code> quite often 
despite having opted into auto detect.</p>
<div class="alert is-helpful"><p>Rather than wonder when the test fixture will or won&#39;t perform change detection,
the samples in this chapter <em>always call</em> <code>detectChanges()</code> <em>explicitly</em>.</p>
</div><a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="component-with-dependency"></a><h1 id="test-a-component-with-a-dependency">Test a component with a dependency</h1>
<p>Components often have service dependencies.
The <code>WelcomeComponent</code> displays a welcome message to the logged in user.
It knows who the user is based on a property of the injected <code>UserService</code>:</p>
<div class="code-example"><header><h4>app/welcome.component.ts</h4></header><code-example language="ts" format="">import { Component, OnInit } from &#39;@angular/core&#39;;
import { UserService }       from &#39;./model&#39;;

@Component({
  selector: &#39;app-welcome&#39;,
  template: &#39;&lt;h3 class=&quot;welcome&quot; &gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;&#39;
})
export class WelcomeComponent  implements OnInit {
  welcome = &#39;-- not initialized yet --&#39;;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.welcome = this.userService.isLoggedIn ?
      &#39;Welcome, &#39; + this.userService.user.name :
      &#39;Please log in.&#39;;
  }
}
</code-example></div><p>The <code>WelcomeComponent</code> has decision logic that interacts with the service;
such logic makes this component worth testing.
Here&#39;s the test module configuration for the spec file, <code>app/welcome.component.spec.ts</code>:</p>
<div class="code-example"><header><h4>app/welcome.component.spec.ts</h4></header><code-example language="ts" format="">    TestBed.configureTestingModule({
       declarations: [ WelcomeComponent ],
    // providers:    [ UserService ]  // a real service would be a problem!
       providers:    [ {provide: UserService, useValue: fakeUserService } ]
    });
</code-example></div><p>This time, in addition to declaring the component under test,
the configurations sets the <code>providers</code> list with the dependent <code>UserService</code>.</p>
<p>This example configures the test module with a <em>fake</em> <code>UserService</code>.</p>
<h2 id="provide-service-fakes">Provide service fakes</h2>
<p>A component under test doesn&#39;t have to be injected with real services. 
In fact, it is usually better if they are fakes.
The purpose of the spec is to test the component, not the service,
and real services can be trouble.</p>
<p>Injecting the real <code>UserService</code> could be a nightmare. 
The real service might try to ask the user for login credentials and 
try to reach an authentication server.
These behaviors could be hard to intercept. 
It is far easier to create and register a fake <code>UserService</code>.</p>
<p>There are many ways to fake a service. 
This test suit supplies a minimal <code>UserService</code> that satisfies the needs of the <code>WelcomeComponent</code>
and its tests:</p>
<div class="code-example"><code-example language="ts" format="">const fakeUserService = {
  isLoggedIn: true,
  user: { name: &#39;Test User&#39;}
};
</code-example></div><a id="injected-service-reference"></a><h2 id="referencing-injected-services">Referencing injected services</h2>
<p>The tests need access to the injected (fake) <code>UserService</code>.</p>
<p>You cannot reference the <code>fakeUserService</code> object provided to the test module. 
<strong>It does not work!</strong> 
Surprisingly, the instance actually injected into the component is <em>not the same</em> 
as the provided <code>fakeUserService</code> object.</p>
<div class="alert is-important"><p>Always use an injector to get a reference to an injected service.</p>
</div><p>Where do you get the injector? 
Angular has an hierarchical injection system.
In a test there can be injectors at multiple levels.
The current <code>TestBed</code> injector creates a top-level injector.
The <code>WelcomeComponent</code> injector is a child of that injector created specifically for the component.</p>
<p>You can get a <code>UserService</code> from the current <code>TestBed</code> injector by calling <code>TestBed.get</code>.</p>
<div class="code-example"><header><h4>TestBed injector</h4></header><code-example language="ts" format="">// UserService provided to the TestBed
userService = TestBed.get(UserService);
</code-example></div><div class="l-sub-section"><p>The <a href="#inject">inject</a> function is another way to inject one or more services into a test.</p>
</div><p>That happens to work for testing the <code>WelcomeComponent</code> because the <code>UserService</code> instance from the <code>TestBed</code>
is the same as the <code>UserService</code> instance injected into the component.</p>
<p>That won&#39;t always be the case.
Be absolutely sure to reference the service instance that the component is <em>actually receiving</em>,
Call <code>get</code> on the component&#39;s injector which is <code>fixture.debugElement.injector</code>:</p>
<div class="code-example"><header><h4>Component's injector</h4></header><code-example language="ts" format="">// UserService actually injected into the component
userService = fixture.debugElement.injector.get(UserService);
</code-example></div><div class="alert is-important"><p>Use the component&#39;s own injector to get the component&#39;s injected service.</p>
</div><a id="welcome-spec-setup"></a><p>Here&#39;s the complete, preferred <code>beforeEach</code>:</p>
<div class="code-example"><header><h4>app/welcome.component.spec.ts</h4></header><code-example language="ts" format="">  beforeEach(() =&gt; {
    // fake UserService for test purposes
    const fakeUserService = {
      isLoggedIn: true,
      user: { name: &#39;Test User&#39;}
    };

    TestBed.configureTestingModule({
       declarations: [ WelcomeComponent ],
       providers:    [ {provide: UserService, useValue: fakeUserService } ]
    });

    fixture = TestBed.createComponent(WelcomeComponent);
    comp    = fixture.componentInstance;

    // UserService actually injected into the component
    userService = fixture.debugElement.injector.get(UserService);

    //  get the &quot;welcome&quot; element by CSS selector (e.g., by class name)
    welcomeEl = fixture.debugElement.query(By.css(&#39;.welcome&#39;));
  });
</code-example></div><p>And here are some tests:</p>
<div class="code-example"><header><h4>app/welcome.component.spec.ts</h4></header><code-example language="ts" format="">it(&#39;should welcome the user&#39;, () =&gt; {
  fixture.detectChanges(); // trigger data binding

  let content = welcomeEl.nativeElement.textContent;
  expect(content).toContain(&#39;Welcome&#39;, &#39;&quot;Welcome ...&quot;&#39;);
  expect(content).toContain(&#39;Test User&#39;, &#39;expected name&#39;);
});

it(&#39;should welcome &quot;Bubba&quot;&#39;, () =&gt; {
  userService.user.name = &#39;Bubba&#39;; // welcome message hasn&#39;t been shown yet

  fixture.detectChanges(); // trigger data binding

  let content = welcomeEl.nativeElement.textContent;
  expect(content).toContain(&#39;Bubba&#39;);
});

it(&#39;should request login if not logged in&#39;, () =&gt; {
  userService.isLoggedIn = false; // welcome message hasn&#39;t been shown yet

  fixture.detectChanges(); // trigger data binding

  let content = welcomeEl.nativeElement.textContent;
  expect(content).not.toContain(&#39;Welcome&#39;, &#39;not welcomed&#39;);
  expect(content).toMatch(/log in/i, &#39;&quot;log in&quot;&#39;);
});
</code-example></div><p>The first is a sanity test; it confirms that the fake <code>UserService</code> is working.
The remaining tests confirm the logic of the component when the service returns different values.
The second test validates the effect of changing the user name.
The third test checks that the component displays the proper message when there is no logged-in user.</p>
<a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="component-with-async-service"></a><h1 id="test-a-component-with-an-async-service">Test a component with an async service</h1>
<p>Many services return values asynchronously. 
Most data services make an HTTP request to a remote server and the response is necessarily asynchronous.</p>
<p>The &quot;About&quot; view in this sample displays Mark Twain quotes.
The <code>TwainComponent</code> handles the display, delegating the server request to the <code>TwainService</code>.
Both are in the <code>app/shared</code> folder because the author intends to display Twain quotes on other pages someday.
Here is the <code>TwainComponent</code>.</p>
<div class="code-example"><header><h4>app/shared/twain.component.ts</h4></header><code-example language="ts" format="">@Component({
  selector: &#39;twain-quote&#39;,
  template: &#39;&lt;p class=&quot;twain&quot;&gt;&lt;i&gt;{{quote}}&lt;/i&gt;&lt;/p&gt;&#39;
})
export class TwainComponent  implements OnInit {
  intervalId: number;
  quote = &#39;...&#39;;
  constructor(private twainService: TwainService) { }

  ngOnInit(): void {
    this.twainService.getQuote().then(quote =&gt; this.quote = quote);
  }
}
</code-example></div><p>The <code>TwainService</code> implementation is irrelevant at this point.
It is sufficient to see within <code>ngOnInit</code> that <code>twainService.getQuote</code> returns a promise which means it is asynchronous.</p>
<p>In general, tests should not make calls to remote servers. 
They should fake such calls. The setup in this <code>app/shared/twain.component.spec.ts</code> shows one way to do that: </p>
<div class="code-example"><header><h4>app/shared/twain.component.spec.ts (setup)</h4></header><code-example language="ts" format="">  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
       declarations: [ TwainComponent ],
       providers:    [ TwainService ],
    });

    fixture = TestBed.createComponent(TwainComponent);
    comp    = fixture.componentInstance;

    // TwainService actually injected into the component
    twainService = fixture.debugElement.injector.get(TwainService);

    // Setup spy on the `getQuote` method
    spy = spyOn(twainService, &#39;getQuote&#39;)
          .and.returnValue(Promise.resolve(testQuote));

    // Get the Twain quote element by CSS selector (e.g., by class name)
    twainEl = fixture.debugElement.query(By.css(&#39;.twain&#39;));
  });
</code-example></div><a id="service-spy"></a><h3 id="spying-on-the-real-service">Spying on the real service</h3>
<p>This setup is similar to the <a href="#welcome-spec-setup"><code>welcome.component.spec</code> setup</a>.
But instead of creating a fake service object, it injects the <em>real</em> service (see the test module <code>providers</code>) and 
replaces the critical <code>getQuote</code> method with a Jasmine spy.</p>
<div class="code-example"><code-example language="ts" format="">spy = spyOn(twainService, &#39;getQuote&#39;)
      .and.returnValue(Promise.resolve(testQuote));
</code-example></div><p>The spy is designed such that any call to <code>getQuote</code> receives an immediately resolved promise with a test quote.
The spy bypasses the actual <code>getQuote</code> method and therefore will not contact the server.</p>
<div class="l-sub-section"><p>Faking a service instance and spying on the real service are <em>both</em> great options. 
Pick the one that seems easiest for the current test suite. Don&#39;t be afraid to change your mind.</p>
</div><p>Here are the tests with commentary to follow:</p>
<div class="code-example"><header><h4>app/shared/twain.component.spec.ts (tests)</h4></header><code-example language="ts" format="linenums">  function getQuote() { return twainEl.nativeElement.textContent; }

  it(&#39;should not show quote before OnInit&#39;, () =&gt; {
    expect(getQuote()).toBe(&#39;&#39;, &#39;nothing displayed&#39;);
    expect(spy.calls.any()).toBe(false, &#39;getQuote not yet called&#39;);
  });

  it(&#39;should still not show quote after component initialized&#39;, () =&gt; {
    fixture.detectChanges(); // trigger data binding
    // getQuote service is async =&gt; still has not returned with quote
    expect(getQuote()).toBe(&#39;...&#39;, &#39;no quote yet&#39;);
    expect(spy.calls.any()).toBe(true, &#39;getQuote called&#39;);
  });

  it(&#39;should show quote after getQuote promise (async)&#39;, async(() =&gt; {
    fixture.detectChanges();          // trigger data binding

    fixture.whenStable().then(() =&gt; { // wait for async getQuote
      fixture.detectChanges();        // update view with quote
      expect(getQuote()).toBe(testQuote);
    });
  }));

  it(&#39;should show quote after getQuote promise (fakeAsync)&#39;, fakeAsync(() =&gt; {
    fixture.detectChanges(); // trigger data binding
    tick();                  // wait for async getQuote
    fixture.detectChanges(); // update view with quote
    expect(getQuote()).toBe(testQuote);
  }));
</code-example></div><h3 id="synchronous-tests">Synchronous tests</h3>
<p>The first two tests are synchronous. 
Neither test can prove that a value from the service will be displayed.</p>
<p>Thanks to the spy, the second test verifies that <code>getQuote</code> is called. 
But the quote itself has not arrived, despite the fact that the spy returns a resolved promise.</p>
<p>This test must wait at least one full turn of the JavaScript engine, a least one &quot;tick&quot;, before the
value becomes available. By that time, the test runner has moved on to the next test in the suite.</p>
<p>The test must become an &quot;async test&quot; ... like the third test</p>
<a id="async-fn-in-it"></a><h2 id="the-_async_-function-in-_it_">The <em>async</em> function in <em>it</em></h2>
<p>Notice the <code>async</code> in the third test.</p>
<div class="code-example"><header><h4>app/shared/twain.component.spec.ts (async test)</h4></header><code-example language="ts" format="">it(&#39;should show quote after getQuote promise (async)&#39;, async(() =&gt; {
  fixture.detectChanges();          // trigger data binding

  fixture.whenStable().then(() =&gt; { // wait for async getQuote
    fixture.detectChanges();        // update view with quote
    expect(getQuote()).toBe(testQuote);
  });
}));
</code-example></div><p>The <code>async</code> function is part of the <em>Angular TestBed</em> feature set.
It <em>takes</em> a parameterless function and <em>returns</em> a parameterless function
which becomes the argument to the  Jasmine <code>it</code> call. </p>
<p>The body of the <code>async</code> argument looks much like the body of a normal <code>it</code> argument.
There is nothing obviously asynchronous about it. For example, it doesn&#39;t return a promise.</p>
<p>The <code>async</code> function arranges for the tester&#39;s code to run in a special <em>async test zone</em>
that almost hides the mechanics of asynchronous execution.</p>
<p>Almost but not completely.</p>
<a id="when-stable"></a><h2 id="_whenstable_"><em>whenStable</em></h2>
<p>The test must wait for the <code>getQuote</code> promise to resolve. </p>
<p>The <code>getQuote</code> promise promise resolves in the next turn of the JavaScript engine, thanks to the spy.
But a different test implementation of  <code>getQuote</code> could take longer.
An integration test might call the <em>real</em> <code>getQuote</code>, resulting in an XHR request
that took many seconds to respond.</p>
<p>This test has no direct access to the promise returned by the call to <code>testService.getQuote</code> 
which is private and inaccessible inside <code>TwainComponent</code>.</p>
<p>Fortunately, the <code>getQuote</code> promise is accessible to the <em>async test zone</em> 
which intercepts all promises issued within the <em>async</em> method call.</p>
<p>The <code>ComponentFixture.whenStable</code> method returns its own promise which resolves when the <code>getQuote</code> promise completes.
In fact, the <em>whenStable</em> promise resolves when <em>all pending asynchronous activities</em> complete ... the definition of &quot;stable&quot;.</p>
<p>Then the testing continues. 
The test kicks off another round of change detection (<code>fixture.detechChanges</code>) which tells Angular to update the DOM with the quote.
The <code>getQuote</code> helper method extracts the display element text and the expectation confirms that the text matches the test quote.</p>
<a id="fakeAsync"></a><a id="fake-async"></a><h2 id="the-_fakeasync_-function">The <em>fakeAsync</em> function</h2>
<p>The fourth test verifies the same component behavior in a different way.</p>
<div class="code-example"><header><h4>app/shared/twain.component.spec.ts (fakeAsync test)</h4></header><code-example language="ts" format="">it(&#39;should show quote after getQuote promise (fakeAsync)&#39;, fakeAsync(() =&gt; {
  fixture.detectChanges(); // trigger data binding
  tick();                  // wait for async getQuote
  fixture.detectChanges(); // update view with quote
  expect(getQuote()).toBe(testQuote);
}));
</code-example></div><p>Notice that <code>fakeAsync</code> replaces <code>async</code> as the <code>it</code> argument.
The <code>fakeAsync</code> function is also part of the <em>Angular TestBed</em> feature set.
Like <code>async</code>, it too <em>takes</em> a parameterless function and <em>returns</em> a parameterless function
which becomes the argument to the  Jasmine <code>it</code> call. </p>
<p>The <code>async</code> function arranges for the tester&#39;s code to run in a special <em>fakeAsync test zone</em>.</p>
<p>The key advantage of <code>fakeAsync</code> is that the test body looks entirely synchronous.
There are no promises at all. 
No <code>then(...)</code> chains to disrupt the visible flow of control.</p>
<div class="l-sub-section"><p>There are limitations. For example, you cannot make an XHR call from within a <code>fakeAsync</code>.</p>
</div><a id="tick"></a><a id="tick-first-look"></a><h2 id="the-_tick_-function">The <em>tick</em> function</h2>
<p>Compare the third and fourth tests. Notice that <code>fixture.whenStable</code> is gone, replaced by <code>tick()</code>.</p>
<p>The <code>tick</code> function is a part of the <em>Angular TestBed</em> feature set and a companion to <code>fakeAsync</code>.
It can only be called within a <code>fakeAsync</code> body.</p>
<p>Calling <code>tick()</code> simulates the passage of time until all pending asynchronous activities complete,
including the resolution of the <code>getQuote</code> promise in this test case.</p>
<p>It returns nothing. There is no promise to wait for. 
Proceed with the same test code as formerly appeared within the <code>whenStable.then()</code> callback.</p>
<p>Even this simple example is easier to read than the third test. 
To more fully appreciate the improvement, imagine a succession of asynchronous operations, 
chained in a long sequence of promise callbacks.</p>
<a id="jasmine-done"></a><h2 id="_jasmine-done_"><em>jasmine.done</em></h2>
<p>While <code>fakeAsync</code> and even <code>async</code> function greatly simplify Angular asynchronous testing,
you can still fallback to the traditional Jasmine asynchronous testing technique.</p>
<p>You can still pass <code>it</code> a function that takes a 
<a href="http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support"><code>done</code> callback</a>.
Now you are responsible for chaining promises, handling errors, and calling <code>done</code> at the appropriate moment.</p>
<p>Here is a <code>done</code> version of the previous two tests:</p>
<div class="code-example"><header><h4>app/shared/twain.component.spec.ts (done test)</h4></header><code-example language="ts" format="">it(&#39;should show quote after getQuote promise (done)&#39;, done =&gt; {
  fixture.detectChanges();   // trigger data binding

  // get the spy promise and wait for it to resolve
  spy.calls.mostRecent().returnValue.then(() =&gt; {
    fixture.detectChanges(); // update view with quote
    expect(getQuote()).toBe(testQuote);
    done();
  });
});
</code-example></div><p>Although we have no direct access to the <code>getQuote</code> promise inside <code>TwainComponent</code>,
the spy does and that makes it possible to wait for <code>getQuote</code> to finish.</p>
<p>The <code>jasmine.done</code> technique, while discouraged, may become necessary when neither <code>async</code> nor <code>fakeAsync</code>
can tolerate a particular asynchronous activity. That&#39;s rare but it happens.</p>
<a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="component-with-external-template"></a><h1 id="test-a-component-with-an-external-template">Test a component with an external template</h1>
<p>The <code>TestBed.createComponent</code> is a synchronous method. 
It assumes that everything it could need is already in memory.</p>
<p>That has been true so far. 
Each tested component&#39;s <code>@Component</code> metadata has a <code>template</code> property specifying an <em>inline templates</em>.
Neither component had a <code>styleUrls</code> property.
Everything necessary to compile them was in memory at test runtime.</p>
<p>The <code>DashboardHeroComponent</code> is different. 
It has an external template and external css file, specified in <code>templateUrl</code> and <code>styleUrls</code> properties.</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.ts (component)</h4></header><code-example language="ts" format="">@Component({
  selector:    &#39;dashboard-hero&#39;,
  templateUrl: &#39;app/dashboard/dashboard-hero.component.html&#39;,
  styleUrls:  [&#39;app/dashboard/dashboard-hero.component.css&#39;]
})
export class DashboardHeroComponent {
  @Input() hero: Hero;
  @Output() selected = new EventEmitter&lt;Hero&gt;();
  click() { this.selected.next(this.hero); }
}
</code-example></div><p>The compiler must read these files from a file system before it can create a component instance.</p>
<p>The <code>TestBed.compileComponents</code> method asynchronously compiles all the components configured in its
current test module. After it completes, external templates and css files, have been &quot;inlined&quot;
and <code>TestBed.createComponent</code> can do its job synchronously.</p>
<div class="l-sub-section"><p>WebPack developers need not call <code>compileComponents</code> because it inlines templates and css
as part of the automated build process that precedes running the test.</p>
</div><p>The <code>app/dashboard/dashboard-hero.component.spec.ts</code> demonstrates the pre-compilation process:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.spec.ts (compileComponents)</h4></header><code-example language="ts" format="">// asynch beforeEach
beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ DashboardHeroComponent ],
  })
  .compileComponents(); // compile template and css
}));
</code-example></div><a id="async-fn-in-before-each"></a><h2 id="the-_async_-function-in-_beforeeach_">The <em>async</em> function in <em>beforeEach</em></h2>
<p>Notice the <code>async</code> call in the <code>beforeEach</code>.</p>
<p>The <code>async</code> function is part of the <em>Angular TestBed</em> feature set.
It <em>takes</em> a parameterless function and <em>returns</em> a parameterless function
which becomes the argument to the Jasmine <code>beforeEach</code> call. </p>
<p>The body of the <code>async</code> argument looks much like the body of a normal <code>beforEach</code> argument.
There is nothing obviously asynchronous about it. For example, it doesn&#39;t return a promise.</p>
<p>The <code>async</code> function arranges for the tester&#39;s code to run in a special <em>async test zone</em>
that hides the mechanics of asynchronous execution.</p>
<a id="compile-components"></a><h2 id="_compilecomponents_"><em>compileComponents</em></h2>
<p>In this example, <code>Testbed.compileComponents</code> compiles one component, the <code>DashboardComponent</code>. 
It&#39;s the only declared component in this test module.</p>
<p>Tests later in this chapter have more declared components and some of them import application
modules that declare yet more components.
Some or all of these components could have external templates and css files.
<code>TestBed.compileComponents</code> compiles them all asynchonously at one time.</p>
<p>The <code>compileComponents</code> method returns a promise so you can perform additional tasks <em>after</em> it finishes.</p>
<h3 id="_compilecomponents_-closes-configuration"><em>compileComponents</em> closes configuration</h3>
<p>After <code>compileComponents</code> runs, the current <code>TestBed</code> instance is closed to further configuration.
You cannot call any more <code>TestBed</code> configuration methods, not <code>configureTestModule</code> 
nor any of the <code>override...</code> methods. The <code>TestBed</code> throws an error if you try.</p>
<div class="alert is-important"><p>Do not configure the <code>TestBed</code> after calling <code>compileComponents</code>. 
Make <code>compileComponents</code> the last step 
before calling <code>TestBed.createInstance</code> to instantiate the test component.</p>
</div><p>The <code>DashboardHeroComponent</code> spec follows the asynchonous <code>beforeEach</code> with a
<em>synchronous</em> <code>beforeEach</code> that completes the setup steps and runs tests ... as described in the next section.</p>
<div class="l-hr"></div><a id="component-with-inputs-outputs"></a><h1 id="test-a-component-with-inputs-and-outputs">Test a component with inputs and outputs</h1>
<p>A component with inputs and outputs typically appears inside the view template of a host component.
The host uses a property binding to set the input property and uses an event binding to
listen to events raised by the output property.</p>
<p>The testing goal is to verify that such bindings work as expected. 
The tests should set input values and listen for output events.</p>
<p>The <code>DashboardHeroComponent</code> is tiny example of a component in this role.
It displays an individual heroe provided by the <code>DashboardComponent</code>. 
Clicking that hero tells the the <code>DashboardComponent</code> that the user has selected the hero.</p>
<p>The <code>DashboardHeroComponent</code> is embedded in the <code>DashboardComponent</code> template like this:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard.component.html (excerpt)</h4></header><code-example language="html" format="">&lt;dashboard-hero *ngFor=&quot;let hero of heroes&quot;  class=&quot;col-1-4&quot;
  [hero]=hero  (selected)=&quot;gotoDetail($event)&quot; &gt;
&lt;/dashboard-hero&gt;
</code-example></div><p>The <code>DashboardHeroComponent</code> appears in an <code>*ngFor</code> repeater which sets each component&#39;s <code>hero</code> input property
to the iteration value and listens for the components <code>selected</code> event.</p>
<p>Here&#39;s the component&#39;s definition again:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.ts (component)</h4></header><code-example language="ts" format="">@Component({
  selector:    &#39;dashboard-hero&#39;,
  templateUrl: &#39;app/dashboard/dashboard-hero.component.html&#39;,
  styleUrls:  [&#39;app/dashboard/dashboard-hero.component.css&#39;]
})
export class DashboardHeroComponent {
  @Input() hero: Hero;
  @Output() selected = new EventEmitter&lt;Hero&gt;();
  click() { this.selected.next(this.hero); }
}
</code-example></div><p>While testing a component this simple has little intrinsic value, it&#39;s worth knowing how.
Three approaches come to mind:</p>
<ol>
<li>Test it as used by <code>DashboardComponent</code></li>
<li>Test it as a stand-alone component</li>
<li>Test it as used by a substitute for <code>DashboardComponent</code></li>
</ol>
<p>A quick look at the <code>DashboardComponent</code> constructor discourages the first approach:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard.component.ts (constructor)</h4></header><code-example language="ts" format="">constructor(
  private router: Router,
  private heroService: HeroService) {
}
</code-example></div><p>The <code>DashboardComponent</code> depends upon the Angular router and the <code>HeroService</code>.
You&#39;d probably have to fake them both and that&#39;s a lot of work. The router is particularly challenging (see below).</p>
<p>The immediate goal is to test the <code>DashboardHeroComponent</code>, not the <code>DashboardComponent</code>, and there&#39;s no need
to work hard unnecessarily. Let&#39;s try the second and third options.</p>
<h2 id="test-_dashboardherocomponent_-stand-alone">Test <em>DashboardHeroComponent</em> stand-alone</h2>
<p>Here&#39;s the spec file setup.</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.spec.ts (setup)</h4></header><code-example language="ts" format="">  // asynch beforeEach
  beforeEach( async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ DashboardHeroComponent ],
    })
    .compileComponents(); // compile template and css
  }));

  // synchronous beforeEach
  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(DashboardHeroComponent);
    comp    = fixture.componentInstance;
    heroEl  = fixture.debugElement.query(By.css(&#39;.hero&#39;)); // find hero element

    // pretend that it was wired to something that supplied a hero
    expectedHero = new Hero(42, &#39;Test Name&#39;);
    comp.hero = expectedHero;
    fixture.detectChanges(); // trigger initial data binding
  });
</code-example></div><p>The async <code>beforeEach</code> was discussed <a href="#component-with-external-template">above</a>.
Having compiled the components asynchronously with <code>compileComponents</code>, the rest of the setup
proceeds <em>synchronously</em> in a <em>second</em> <code>beforeEach</code>, using the basic techniques described <a href="#simple-component-test">earlier</a>.</p>
<p>Note how the setup code assigns a test hero (<code>expectedHero</code>) to the component&#39;s <code>hero</code> property, emulating
the way the <code>DashboardComponent</code> would set it via the property binding in its repeater.</p>
<p>The first test follows:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.spec.ts (name test)</h4></header><code-example language="ts" format="">it(&#39;should display hero name&#39;, () =&gt; {
  const expectedPipedName = expectedHero.name.toUpperCase();
  expect(heroEl.nativeElement.textContent).toContain(expectedPipedName);
});
</code-example></div><p>It verifies that the hero name is propagated through to template with a binding.
There&#39;s a twist. The template passes the hero name through the Angular <code>UpperCasePipe</code> so the
test must match the element value with the uppercased name:</p>
<div class="code-example"><code-example language="html" format="">&lt;div (click)=&quot;click()&quot; class=&quot;hero&quot;&gt;
  {{hero.name | uppercase}}
&lt;/div&gt;
</code-example></div><div class="alert is-helpful"><p>This small test demonstrates how Angular tests can verify a component&#39;s visual representation
&mdash; something not possible with <a href="#isolated-component-tests">isolated unit tests</a> &mdash;
at low cost and without resorting to much slower and more complicated end-to-end tests.</p>
</div><p>The second test verifies click behavior. Clicking the hero should raise a <code>selected</code> event that the
host component (<code>DashboardComponent</code> presumably) can hear:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.spec.ts (click test)</h4></header><code-example language="ts" format="">it(&#39;should raise selected event when clicked&#39;, () =&gt; {
  let selectedHero: Hero;
  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);

  heroEl.triggerEventHandler(&#39;click&#39;, null);
  expect(selectedHero).toBe(expectedHero);
});
</code-example></div><p>The component exposes an <code>EventEmitter</code> property. The test subscribes to it just as the host component would do.</p>
<p>The Angular <code>DebugElement.triggerEventHandler</code> lets the test raise <em>any data-bound event</em>.
In this example, the component&#39;s template binds to the hero <code>&lt;div&gt;</code>.</p>
<p>The test has a reference to that <code>&lt;div&gt;</code> in <code>heroEl</code> so triggering the <code>heroEl</code> click event should cause Angular
to call <code>DashboardHeroComponent.click</code>. </p>
<p>If the component behaves as expected, its <code>selected</code> property should emit the <code>hero</code> object,
the test detects that emission through its subscription, and the test will pass.</p>
<div class="l-hr"></div><a id="component-inside-test-host"></a><h1 id="test-a-component-inside-a-test-host-component">Test a component inside a test host component</h1>
<p>In the previous approach the tests themselves played the role of the host <code>DashboardComponent</code>.
A nagging suspicion remains. 
Will the <code>DashboardHeroComponent</code> work properly when properly data-bound to a host component? </p>
<p>Testing with the actual <code>DashboardComponent</code> host is doable but seems more trouble than its worth.
It&#39;s easier to emulate the <code>DashboardComponent</code> host with a <em>test host</em> like this one:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.spec.ts (test host)</h4></header><code-example language="ts" format="">@Component({
  template: `
    &lt;dashboard-hero  [hero]=&quot;hero&quot;  (selected)=&quot;onSelected($event)&quot;&gt;
    &lt;/dashboard-hero&gt;`
})
class TestHostComponent {
  hero = new Hero(42, &#39;Test Name&#39;);
  selectedHero: Hero;
  onSelected(hero: Hero) { this.selectedHero = hero; }
}
</code-example></div><p>The test host binds to <code>DashboardHeroComponent</code> as the <code>DashboardComponent</code> would but without
the distraction of the <code>Router</code>, the <code>HeroService</code> or even the <code>*ngFor</code> repeater.</p>
<p>The test host sets the component&#39;s <code>hero</code> input property with its test hero.
It binds the component&#39;s <code>selected</code> event with its <code>onSelected</code> handler that records the emitted hero
in its <code>selectedHero</code> property. Later the tests check that property to verify that the
<code>DashboardHeroComponent.selected</code> event really did emit the right hero.</p>
<p>The setup for the test-host tests is similar to the setup for the stand-alone tests:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.spec.ts (test host setup)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ DashboardHeroComponent, TestHostComponent ], // declare both
  }).compileComponents();
}));

beforeEach(() =&gt; {
  // create TestHosComponent instead of DashboardHeroComponent
  fixture  = TestBed.createComponent(TestHostComponent);
  testHost = fixture.componentInstance;
  heroEl   = fixture.debugElement.query(By.css(&#39;.hero&#39;)); // find hero
  fixture.detectChanges(); // trigger initial data binding
});
</code-example></div><p>This test module configuration shows two important differences:</p>
<ol>
<li>It <em>declares</em> both the <code>DashboardHeroComponent</code> and the <code>TestHostComponent</code>.</li>
<li>It <em>creates</em> the <code>TestHostComponent</code> instead of the <code>DashboardHeroComponent</code>.</li>
</ol>
<p>The <code>fixture</code> returned by <code>createComponent</code> holds an instance of <code>TestHostComponent</code> instead of an instance of <code>DashboardHeroComponent</code>.</p>
<p>Of course creating the <code>TestHostComponent</code> has the side-effect of creating a <code>DashboardHeroComponent</code>
because the latter appears within the template of the former. 
The query for the hero element (<code>heroEl</code>) still finds it in the test DOM 
albeit at greater depth in the element tree than before.</p>
<p>The tests themselves are almost identical to the stand-alone version</p>
<div class="code-example"><header><h4>app/dashboard/dashboard-hero.component.spec.ts (test-host)</h4></header><code-example language="ts" format="">it(&#39;should display hero name&#39;, () =&gt; {
  const expectedPipedName = testHost.hero.name.toUpperCase();
  expect(heroEl.nativeElement.textContent).toContain(expectedPipedName);
});

it(&#39;should raise selected event when clicked&#39;, () =&gt; {
  heroEl.triggerEventHandler(&#39;click&#39;, null);
  // selected hero should be the same data bound hero
  expect(testHost.selectedHero).toBe(testHost.hero);
});
</code-example></div><p>Only the selected event test differs. It confirms that the selected <code>DashboardHeroComponent</code> hero
really does find its way up through the event binding to the host component.</p>
<a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="routed-component"></a><h1 id="test-a-routed-component">Test a routed component</h1>
<p>Testing the actual <code>DashboardComponent</code> seemed daunting because it injects the <code>Router</code>.</p>
<div class="code-example"><header><h4>app/dashboard/dashboard.component.ts (constructor)</h4></header><code-example language="ts" format="">constructor(
  private router: Router,
  private heroService: HeroService) {
}
</code-example></div><p>It also injects the <code>HeroService</code> but faking that is a <a href="#component-with-async-servic">familiar story</a>.
The <code>Router</code> has a complicated API and is entwined with other services and application pre-conditions.</p>
<p>Fortunately, the <code>DashboardComponent</code> isn&#39;t doing much with the <code>Router</code></p>
<div class="code-example"><header><h4>app/dashboard/dashboard.component.ts (goToDetail)</h4></header><code-example language="ts" format="">gotoDetail(hero: Hero) {
  let url = `/heroes/${hero.id}`;
  this.router.navigateByUrl(url);
}
</code-example></div><p>This is often the case.
As a rule you test the component, not the router,
and care only if the component navigates with the right address under the given conditions.
Faking the router is an easy option. This should do the trick:</p>
<div class="code-example"><header><h4>app/dashboard/dashboard.component.spec.ts (fakeRouter)</h4></header><code-example language="ts" format="">class FakeRouter {
  navigateByUrl(url: string) { return url;  }
}
</code-example></div><p>Now we setup the test module with the <code>fakeRouter</code> and a fake <code>HeroService</code> and 
create a test instance of the <code>DashbaordComponent</code> for subsequent testing.</p>
<div class="code-example"><header><h4>app/dashboard/dashboard.component.spec.ts (compile and create)</h4></header><code-example language="ts" format="">beforeEach( async(() =&gt; {
  TestBed.configureTestingModule({
    providers: [
      { provide: HeroService, useClass: FakeHeroService },
      { provide: Router,      useClass: FakeRouter }
    ]
  })
  .compileComponents().then(() =&gt; {
    fixture = TestBed.createComponent(DashboardComponent);
    comp = fixture.componentInstance;
  });
</code-example></div><p>The following test clicks the displayed hero and confirms (with the help of a spy) that <code>Router.navigateByUrl</code> is called with the expected url.</p>
<div class="code-example"><header><h4>app/dashboard/dashboard.component.spec.ts (navigate test)</h4></header><code-example language="ts" format="">    it(&#39;should tell ROUTER to navigate when hero clicked&#39;,
      inject([Router], (router: Router) =&gt; { // ...

      const spy = spyOn(router, &#39;navigateByUrl&#39;);

      heroClick(); // trigger click on first inner &lt;div class=&quot;hero&quot;&gt;

      // args passed to router.navigateByUrl()
      const navArgs = spy.calls.first().args[0];

      // expecting to navigate to id of the component&#39;s first hero
      const id = comp.heroes[0].id;
      expect(navArgs).toBe(&#39;/heroes/&#39; + id,
        &#39;should nav to HeroDetail for first hero&#39;);
    }));
</code-example></div><a id="inject"></a><h2 id="the-_inject_-function">The <em>inject</em> function</h2>
<p>Notice the <code>inject</code> function in the second <code>it</code> argument.</p>
<div class="code-example"><code-example language="ts" format="">it(&#39;should tell ROUTER to navigate when hero clicked&#39;,
  inject([Router], (router: Router) =&gt; { // ...
}));
</code-example></div><p>The <code>inject</code> function is part of the <em>Angular TestBed</em> feature set.
It injects services into the test function where you can alter, spy on, and manipulate them.</p>
<p>The <code>inject</code> function has two parameters</p>
<ol>
<li>an array of Angular dependency injection tokens</li>
<li>a test function whose parameters correspond exactly to each item in the injection token array</li>
</ol>
<div class="callout is-important"><header>inject uses the TestBed Injector</header><p>The <code>inject</code> function uses the current <code>TestBed</code> injector and can only return services provided at that level.
It does not return services from component providers.</p>
</div><p>This example injects the <code>Router</code> from the current <code>TestBed</code> injector.
That&#39;s fine for this test because the <code>Router</code> is (and must be) provided by the application root injector.</p>
<p>If you need a service provided by the component&#39;s <em>own</em> injector,  call <code>fixture.debugElement.injector.get</code> instead:</p>
<div class="code-example"><header><h4>Component's injector</h4></header><code-example language="ts" format="">// UserService actually injected into the component
userService = fixture.debugElement.injector.get(UserService);
</code-example></div><div class="alert is-important"><p>Use the component&#39;s own injector to get the service actually injected into the component.</p>
</div><p>The <code>inject</code> function closes the current <code>TestBed</code> instance to further configuration.
You cannot call any more <code>TestBed</code> configuration methods, not <code>configureTestModule</code>
nor any of the <code>override...</code> methods. The <code>TestBed</code> throws an error if you try.</p>
<div class="alert is-important"><p>Do not configure the <code>TestBed</code> after calling <code>inject</code>.</p>
</div><a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="isolated-tests"></a><a id="testing-without-atp"></a><h1 id="testing-without-the-angular-testing-platform">Testing without the Angular Testing Platform</h1>
<p>Testing applications with the help of the Angular Testing Platform (ATP) is the main focus of this chapter.</p>
<p>However, it&#39;s often more productive to explore the inner logic of application classes
with <em>isolated</em>  unit tests that don&#39;t use the ATP.
Such tests are often smaller, easier to read,
and easier to write and maintain.</p>
<p>They don&#39;t</p>
<ul>
<li>import from the Angular test libraries</li>
<li>configure a module</li>
<li>prepare dependency injection <code>providers</code></li>
<li>call <code>inject</code> or <code>async</code> or <code>fakeAsync</code></li>
</ul>
<p>They do</p>
<ul>
<li>exhibit standard, Angular-agnostic testing techniques</li>
<li>create instances directly with <code>new</code></li>
<li>use stubs, spys, and mocks to fake dependencies.</li>
</ul>
<div class="callout is-important"><header>Write both kinds of tests</header><p>Good developers write both kinds of tests for the same application part, often in the same spec file.
Write simple <em>isolated</em> unit tests to validate the part in isolation.
Write <em>Angular</em> tests to validate the part as it interacts with Angular,
updates the DOM, and collaborates with the rest of the application.</p>
</div><h2 id="services">Services</h2>
<p>Services are good candidates for vanilla unit testing. 
Here are some synchronous and asynchronous unit tests of the <code>FancyService</code> 
written without assistance from Angular Testing Platform.</p>
<div class="code-example"><header><h4>app/bag/bag.no-testbed.spec.ts</h4></header><code-example language="ts" format="linenums">// Straight Jasmine - no imports from Angular test libraries

describe(&#39;FancyService without the TestBed&#39;, () =&gt; {
  let service: FancyService;

  beforeEach(() =&gt; { service = new FancyService(); });

  it(&#39;#getValue should return real value&#39;, () =&gt; {
    expect(service.getValue()).toBe(&#39;real value&#39;);
  });

  it(&#39;#getAsyncValue should return async value&#39;, done =&gt; {
    service.getAsyncValue().then(value =&gt; {
      expect(value).toBe(&#39;async value&#39;);
      done();
    });
  });

  it(&#39;#getTimeoutValue should return timeout value&#39;,  done =&gt; {
    service = new FancyService();
    service.getTimeoutValue().then(value =&gt; {
      expect(value).toBe(&#39;timeout value&#39;);
      done();
    });
  });

  it(&#39;#getObservableValue should return observable value&#39;, done =&gt; {
    service.getObservableValue().subscribe(value =&gt; {
      expect(value).toBe(&#39;observable value&#39;);
      done();
    });
  });

});
</code-example></div><p>A rough line count suggests that these tests are about 25% smaller than equivalent ATP tests. 
That&#39;s telling but not decisive. 
The benefit comes from reduced setup and code complexity.</p>
<p>Compare these equivalent tests of <code>FancyService.getTimeoutValue</code>.</p>
<code-tabs><code-pane language="ts" name="app/bag/bag.no-testbed.spec.ts" format="linenums">it(&#39;#getTimeoutValue should return timeout value&#39;,  done =&gt; {
  service = new FancyService();
  service.getTimeoutValue().then(value =&gt; {
    expect(value).toBe(&#39;timeout value&#39;);
    done();
  });
});
</code-pane><code-pane language="ts" name="app/bag/bag.spec.ts (with ATP)" format="linenums">beforeEach(() =&gt; {
  TestBed.configureTestingModule({ providers: [FancyService] });
});

it(&#39;test should wait for FancyService.getTimeoutValue&#39;,
  async(inject([FancyService], (service: FancyService) =&gt; {

  service.getTimeoutValue().then(
    value =&gt; expect(value).toBe(&#39;timeout value&#39;)
  );
})));
</code-pane></code-tabs><p>They have about the same line-count. 
The ATP version has more moving parts, including a couple of helper functions (<code>async</code> and <code>inject</code>).
Both work and it&#39;s not much of an issue if you&#39;re using the Angular Testing Platform nearby for other reasons. 
On the other hand, why burden simple service tests with ATP complexity?</p>
<p>Pick the approach that suits you.</p>
<h3 id="services-with-dependencies">Services with dependencies</h3>
<p>Services often depend on other services that Angular injects into the constructor.
You can test these services <em>without</em> the testbed.
In many cases, it&#39;s easier to create and <em>inject</em> dependencies by hand.</p>
<p>The <code>DependentService</code> is a simple example</p>
<div class="code-example"><header><h4>app/bag/bag.ts</h4></header><code-example language="ts" format="">@Injectable()
export class DependentService {
  constructor(private dependentService: FancyService) { }
  getValue() { return this.dependentService.getValue(); }
}
</code-example></div><p>It delegates it&#39;s only method, <code>getValue</code>, to the injected <code>FancyService</code>.</p>
<p>Here are several ways to test it.</p>
<div class="code-example"><header><h4>app/bag/bag.no-testbed.spec.ts</h4></header><code-example language="ts" format="linenums">describe(&#39;DependentService without the TestBed&#39;, () =&gt; {
  let service: DependentService;

  it(&#39;#getValue should return real value by way of the real FancyService&#39;, () =&gt; {
    service = new DependentService(new FancyService());
    expect(service.getValue()).toBe(&#39;real value&#39;);
  });

  it(&#39;#getValue should return faked value by way of a fakeService&#39;, () =&gt; {
    service = new DependentService(new FakeFancyService());
    expect(service.getValue()).toBe(&#39;faked value&#39;);
  });

  it(&#39;#getValue should return faked value from a fake object&#39;, () =&gt; {
    const fake =  { getValue: () =&gt; &#39;fake value&#39; };
    service = new DependentService(fake as FancyService);
    expect(service.getValue()).toBe(&#39;fake value&#39;);
  });

  it(&#39;#getValue should return stubbed value from a FancyService spy&#39;, () =&gt; {
    const fancy = new FancyService();
    const stubValue = &#39;stub value&#39;;
    const spy = spyOn(fancy, &#39;getValue&#39;).and.returnValue(stubValue);
    service = new DependentService(fancy);

    expect(service.getValue()).toBe(stubValue, &#39;service returned stub value&#39;);
    expect(spy.calls.count()).toBe(1, &#39;stubbed method was called once&#39;);
    expect(spy.calls.mostRecent().returnValue).toBe(stubValue);
  });
});
</code-example></div><p>The first test creates a <code>FancyService</code> with <code>new</code> and passes it to the <code>DependentService</code> constructor.</p>
<p>It&#39;s rarely that simple. The injected service can be difficult to create or control.
You can mock the dependency, or use a fake value, or stub the pertinent service method
with a substitute method that is easy to control.</p>
<p>These <em>isolated</em> unit testing techniques are great for exploring the inner logic of a service or its
simple integration with a component class.
Use the Angular Testing Platform when writing tests that validate how a service interacts with components
<em>within the Angular runtime environment</em>.</p>
<h2 id="pipes">Pipes</h2>
<p>Pipes are easy to test without the Angular Testing Platform (ATP).</p>
<p>A pipe class has one method, <code>transform</code>, that turns an input to an output. 
The <code>transform</code> implementation rarely interacts with the DOM.
Most pipes have no dependence on Angular other than the <code>@Pipe</code>
metadata and an interface.</p>
<p>Consider a <code>TitleCasePipe</code> that capitalizes the first letter of each word.
Here&#39;s a naive implementation implemented with a regular expression.</p>
<div class="code-example"><header><h4>app/shared/title-case.pipe.ts</h4></header><code-example language="ts" format="">import { Pipe, PipeTransform } from &#39;@angular/core&#39;;

@Pipe({name: &#39;titlecase&#39;, pure: false})
/** Transform to Title Case: uppercase the first letter of the words in a string.*/
export class TitleCasePipe implements PipeTransform {
  transform(input: string): string {
    return input.length === 0 ? &#39;&#39; :
      input.replace(/\w\S*/g, (txt =&gt; txt[0].toUpperCase() + txt.substr(1).toLowerCase() ));
  }
}
</code-example></div><p>Anything that uses a regular expression is worth testing thoroughly.
Use simple Jasmine to explore the expected cases and the edge cases.</p>
<div class="code-example"><header><h4>app/shared/title-case.pipe.spec.ts</h4></header><code-example language="ts" format="linenums">describe(&#39;TitleCasePipe&#39;, () =&gt; {
  // This pipe is a pure function so no need for BeforeEach
  let pipe = new TitleCasePipe();

  it(&#39;transforms &quot;abc&quot; to &quot;Abc&quot;&#39;, () =&gt; {
    expect(pipe.transform(&#39;abc&#39;)).toBe(&#39;Abc&#39;);
  });

  it(&#39;transforms &quot;abc def&quot; to &quot;Abc Def&quot;&#39;, () =&gt; {
    expect(pipe.transform(&#39;abc def&#39;)).toBe(&#39;Abc Def&#39;);
  });

  // ... more tests ...
});
</code-example></div><h2 id="write-atp-tests-too">Write ATP tests too</h2>
<p>These are tests of the pipe <em>in isolation</em>.
They can&#39;t tell if the <code>TitleCasePipe</code> is working properly 
as applied in the application components.</p>
<p>Consider adding ATP component tests such as this one.</p>
<div class="code-example"><header><h4>app/hero/hero-detail.component.spec.ts (pipe test)</h4></header><code-example language="ts" format="linenums">it(&#39;should convert original hero name to Title Case&#39;, () =&gt; {
  expect(page.nameDisplay.textContent).toBe(comp.hero.name);
});
</code-example></div><a id="isolated-component-tests"></a><h2 id="components">Components</h2>
<p>Component tests typically examine how a component class interacts with its own template or with collaborating components.
The Angular Testing Platform is specifically designed to facilitate such tests.</p>
<p>Consider this <code>ButtonComp</code> component.</p>
<div class="code-example"><header><h4>app/bag/bag.ts (ButtonComp)</h4></header><code-example language="ts" format="">@Component({
  selector: &#39;button-comp&#39;,
  template: `
    &lt;button (click)=&quot;clicked()&quot;&gt;Click me!&lt;/button&gt;
    &lt;span&gt;{{message}}&lt;/span&gt;`
})
export class ButtonComponent {
  isOn = false;
  clicked() { this.isOn = !this.isOn; }
  get message() { return `The light is ${this.isOn ? &#39;On&#39; : &#39;Off&#39;}`; }
}
</code-example></div><p>The following ATP test demonstrates that clicking a button in the template leads
to an update of the on-screen message.</p>
<div class="code-example"><header><h4>app/bag/bag.spec.ts (ButtonComp)</h4></header><code-example language="ts" format="">it(&#39;should support clicking a button&#39;, () =&gt; {
  const fixture = TestBed.createComponent(ButtonComponent);
  const btn  = fixture.debugElement.query(By.css(&#39;button&#39;));
  const span = fixture.debugElement.query(By.css(&#39;span&#39;)).nativeElement;

  fixture.detectChanges();
  expect(span.textContent).toMatch(/is off/i, &#39;before click&#39;);

  btn.triggerEventHandler(&#39;click&#39;, null);
  fixture.detectChanges();
  expect(span.textContent).toMatch(/is on/i, &#39;after click&#39;);
});
</code-example></div><p>The assertions verify the data binding flow from one HTML control (the <code>&lt;button&gt;</code>) to the component and 
from the component back to a <em>different</em> HTML control (the <code>&lt;span&gt;</code>). 
A passing test means the component and its template are wired up correctly.</p>
<p>Tests <em>without</em> the ATP can more rapidly probe a component at its API boundary,
exploring many more conditions with less effort.</p>
<p>Here are a set of <em>unit tests</em> that verify the component&#39;s outputs in the face of a variety of
component inputs.</p>
<div class="code-example"><header><h4>app/bag/bag.no-testbed.spec.ts (ButtonComp)</h4></header><code-example language="ts" format="">describe(&#39;ButtonComp&#39;, () =&gt; {
  let comp: ButtonComponent;
  beforeEach(() =&gt; comp = new ButtonComponent());

  it(&#39;#isOn should be false initially&#39;, () =&gt; {
    expect(comp.isOn).toBe(false);
  });

  it(&#39;#clicked() should set #isOn to true&#39;, () =&gt; {
    comp.clicked();
    expect(comp.isOn).toBe(true);
  });

  it(&#39;#clicked() should set #message to &quot;is on&quot;&#39;, () =&gt; {
    comp.clicked();
    expect(comp.message).toMatch(/is on/i);
  });

  it(&#39;#clicked() should toggle #isOn&#39;, () =&gt; {
    comp.clicked();
    expect(comp.isOn).toBe(true);
    comp.clicked();
    expect(comp.isOn).toBe(false);
  });
});
</code-example></div><p>Isolated component tests offer a lot of test coverage with less code and almost no setup.
This advantage is even more pronounced with complex components that 
require meticulous preparation with the Angular Testing Platform.</p>
<p>On the other hand, isolated unit tests can&#39;t confirm that the <code>ButtonComp</code> is 
properly bound to its template or even data bound at all. 
Use ATP tests for that.</p>
<a href="#top" class="to-top">Back to top</a><div class="l-hr"></div><a id="atp-api"></a><h1 id="angular-testing-platform-apis">Angular Testing Platform APIs</h1>
<p>This section takes inventory of the most useful <em>Angular Testing Platform</em> features and summarizes what they do.</p>
<p>The <em>Angular Testing Platform</em> consists of the <code>TestBed</code> and <code>ComponentFixture</code> classes plus a handful of functions in the test environment.
The <a href="#testbed-api-summary"><em>TestBed</em></a> and <a href="#componentfixture-api-summary"><em>ComponentFixture</em></a> classes are covered separately.</p>
<p>Here&#39;s a summary of the functions, in order of likely utility:</p>
<table><tr><th>Function</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>async</code></td><td><p>Runs the body of a test (<code>it</code>) or setup (<code>beforeEach</code>) function within a special <em>async test zone</em>.
See <a href="#async-fn-in-it">here</a> and <a href="#async-fn-in-before-each">here</a>.</p>
</td></tr><tr><td style="vertical-align: top"><code>fakeAsync</code></td><td><p>Runs the body of a test (<code>it</code>) within a special <em>fakeAsync test zone</em>, enabling
a linear control flow coding style. See <a href="#fake-async">above</a>.</p>
</td></tr><tr><td style="vertical-align: top"><code>tick</code></td><td><p>Simulates the passage of time and the completion of pending asynchronous activities
by flushing timer and micro-task queues in the <em>fakeAsync test zone</em>.</p>
<p>Accepts an optional argument that moves the virtual clock forward
the specified number of milliseconds, 
clearing asynchronous activities scheduled within that timeframe.
See <a href="#tick">above</a>.</p>
</td></tr><tr><td style="vertical-align: top"> <code>inject</code></td><td><p>Injects one or more services from the current <code>TestBed</code> injector into a test function.
See <a href="#inject">above</a>.</p>
</td></tr><tr><td style="vertical-align: top"><code>discardPeriodicTasks</code></td><td><p>When a <code>fakeAsync</code> test ends with pending timer event tasks (queued <code>setTimeOut</code> and <code>setInterval</code> callbacks),
the test fails with a clear error message.</p>
<p>In general, a test should end with no queued tasks. 
When pending timer tasks are expected, call <code>discardPeriodicTasks</code> to flush the queues
and avoid the error.</p>
</td></tr><tr><td style="vertical-align: top"><code>flushMicrotasks</code></td><td><p>When a <code>fakeAsync</code> test ends with pending &quot;microtasks&quot; such as unresolved promises,
the test fails with a clear error message.</p>
<p>In general, a test should wait for microtasks to finish.
When pending microtasks are expected, call <code>discardPeriodicTasks</code> to flush the queues
and avoid the error.</p>
</td></tr><tr><td style="vertical-align: top"><code>ComponentFixtureAutoDetect</code></td><td><p>A provider token for setting the default <em>auto-changeDetect</em> from its default of <code>false</code>.
See <a href="#automatic-change-detection">automatic change detection</a></p>
</td></tr><tr><td style="vertical-align: top"><code>getTestBed</code></td><td><p>Gets the current instance of the <code>TestBed</code>. 
Usually unnecessary because the static class methods of the <code>TestBed</code> class are typically sufficient.
The <code>TestBed</code> instance exposes a few rarely used members that are not available as
static methods.</p>
</td></tr></table><div class="l-hr"></div><a id="testbed-class-summary"></a><h1 id="_testbed_-class-summary"><em>TestBed</em> Class Summary</h1>
<p>The <code>TestBed</code> class API is quite large and can be overwhelming until you&#39;ve explored it first
a little at a time. Read the early part of this chapter first
to get the basics before trying to absorb the full API.</p>
<div class="alert is-important"><p>The <em>TestBed</em> is officially <em>experimental</em> and thus subject to change.
Consult the <a href="../api/core/testing/index/TestBed-class.html">API reference</a> for the latest status.</p>
</div><p>The module definition passed to <code>configureTestingModule</code>, 
is a subset of the <code>@NgModule</code> metadata properties.</p>
<code-example format="." language="javascript">type TestModuleMetadata = {
  providers?: any[];
  declarations?: any[];
  imports?: any[];
  schemas?: Array&lt;SchemaMetadata | any[]&gt;;
};
</code-example><p>Each overide method takes a <code>MetadataOverride&lt;T&gt;</code> where <code>T</code> is the kind of metadata
appropriate to the method, the parameter of an <code>@NgModule</code>, <code>@Component</code>, <code>@Directive</code>, or <code>@Pipe</code>.</p>
<code-example format="." language="javascript">type MetadataOverride<t> = {
  add?: T;
  remove?: T;
  set?: T;
};
</t></code-example><a id="testbed-methods"></a><p>The <code>TestBed</code> API consists of static class methods that either update or reference a <em>global</em> instance of the<code>TestBed</code>.</p>
<p>Internally, all static methods cover methods of the current runtime <code>TestBed</code> instance that is also returned by the <code>getTestBed()</code> function.</p>
<p>Call <code>TestBed</code> methods <em>within</em> a <code>BeforeEach()</code> to ensure a fresh start before each individual test.</p>
<p>Here are the most important static methods, in order of likely utility.</p>
<table><tr><th>Methods</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>configureTestingModule</code></td><td><p>The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) 
establish the <a href="#a#testbed-initTestEnvironment">initial test environment</a> and a default test module.
The default test module is configured with basic declaratives and some Angular service substitutes (e.g. <code>DebugDomRender</code>) 
that every tester needs.</p>
<p>Call <code>configureTestingModule</code> to refine the test module configuration for a particular set of tests
by adding and removing imports, declarations (of components, directives, and pipes), and providers.</p>
</td></tr><tr><td style="vertical-align: top"><code>compileComponents</code></td><td><p>Compile the test module asynchronously after you&#39;ve finished configuring it.
You <strong>must</strong> call this method if <em>any</em> of the test module components have a <code>templateUrl</code>
or <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous.
See <a href="#compile-components">above</a>.</p>
<p>Once called, the <code>TestBed</code> configuration is frozen for the duration of the current spec.</p>
</td></tr><tr><td style="vertical-align: top"><code>createComponent<t></t></code></td><td><p>Create an instance of a component of type <code>T</code> based on the current <code>TestBed</code> configuration.
Once called, the <code>TestBed</code> configuration is frozen for the duration of the current spec.</p>
</td></tr><tr><td style="vertical-align: top"><code>overrideModule</code></td><td><p>Replace metadata for the given <code>NgModule</code>. Recall that modules can import other modules.
The <code>overrideModule</code> method can reach deeply into the current test module to
modify one of these inner modules.</p>
</td></tr><tr><td style="vertical-align: top"><code>overrideComponent</code></td><td><p>Replace metadata for the given component class which could be nested deeply 
within an inner module.</p>
</td></tr><tr><td style="vertical-align: top"><code>overrideDirective</code></td><td><p>Replace metadata for the given directive class which could be nested deeply 
within an inner module.</p>
</td></tr><tr><td style="vertical-align: top"><code>overridePipe</code></td><td><p>Replace metadata for the given pipe class which could be nested deeply 
within an inner module.</p>
</td></tr><tr><td style="vertical-align: top"><a id="testbed-get"></a>
<code>get</code></td><td><p>Retrieve a service from the current <code>TestBed</code> injector.</p>
<p>The <code>inject</code> function is often adequate for this purpose. 
But <code>inject</code> throws an error if it can&#39;t provide the service. 
What if the service is optional?</p>
<p>The <code>TestBed.get</code> method takes an optional second parameter, 
the object to return if Angular can&#39;t find the provider
(<code>null</code> in this example):</p>
<div class="code-example"><code-example language="ts" format="">service = TestBed.get(FancyService, null);
</code-example></div><p>Once called, the <code>TestBed</code> configuration is frozen for the duration of the current spec.</p>
</td></tr><tr><td style="vertical-align: top"><a id="testbed-initTestEnvironment"></a>
<code>initTestEnvironment</code></td><td><p>Initialize the testing environment for the entire test run.</p>
<p>The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you
so there is rarely a reason for you to call it yourself.</p>
<p>This method may be called <em>exactly once</em>. Call <code>resetTestEnvironment</code> first
if you absolutely need to change this default in the middle of your test run.</p>
<p>Specify the Angular compiler factory, a <code>PlatformRef</code>, and a default Angular test module.
Test modules and platforms for individual platforms are available from
<code>angular2/platform/testing/&lt;platform_name&gt;</code>.</p>
</td></tr><tr><td style="vertical-align: top"><code>resetTestEnvironment</code></td><td><p>Reset the initial test environment including the default test module.</p>
</td></tr></table><p>A few of the <code>TestBed</code> instance methods are not covered by static <code>TestBed</code> <em>class</em> methods.
These are rarely needed.</p>
<a id="componentfixture-api-summary"></a><h2 id="the-_componentfixture_">The <em>ComponentFixture</em></h2>
<p>The <code>TestBed.createComponent&lt;T&gt;</code>
creates an instance of the component <code>T</code> 
and returns a strongly typed <code>ComponentFixture</code> for that component.</p>
<p>The <code>ComponentFixture</code> properties and methods provide access to the component, 
its DOM representation, and aspects of its Angular environment. </p>
<a id="componentfixture-properties"></a><h3 id="_componentfixture_-properties"><em>ComponentFixture</em> properties</h3>
<p>Here are the most important properties for testers, in order of likely utility.</p>
<table><tr><th>Properties</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>componentInstance</code></td><td><p>The instance of the component class created by <code>TestBed.createComponent</code>.</p>
</td></tr><tr><td style="vertical-align: top"><code>debugElement</code></td><td><p>The <code>DebugElement</code> associated with the root element of the component.</p>
<p>The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging.
It&#39;s a critical property for testers. The most interesting members are covered <a href="#debugelement-details">below</a>.</p>
</td></tr><tr><td style="vertical-align: top"><code>nativeElement</code></td><td><p>The native DOM element at the root of the component.</p>
</td></tr><tr><td style="vertical-align: top"><code>changeDetectorRef</code></td><td><p>The <code>ChangeDetectorRef</code> for the component.</p>
<p>The <code>ChangeDetectorRef</code> is most valuable when testing a
component that has the <code>ChangeDetectionStrategy.OnPush</code>
or the component&#39;s change detection is under your programmatic control.</p>
</td></tr></table><a id="componentfixture-methods"></a><h3 id="_componentfixture_-methods"><em>ComponentFixture</em> methods</h3>
<p>The <em>fixture</em> methods cause Angular to perform certain tasks to the component tree.
Call these method to trigger Angular behavior in response to simulated user action.</p>
<p>Here are the most useful methods for testers.</p>
<table><tr><th>Methods</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>detectChanges</code></td><td><p>Trigger a change detection cycle for the component.</p>
<p>Call it to initialize the component (it calls <code>ngOnInit</code>) and after your 
test code change the component&#39;s data bound property values.
Angular can&#39;t see that you&#39;ve changed <code>personComponent.name</code> and won&#39;t update the <code>name</code>
binding until you call <code>detectChanges</code>.</p>
<p>Runs <code>checkNoChanges</code>afterwards to confirm there are no circular updates unless
called as <code>detectChanges(false)</code>;</p>
</td></tr><tr><td style="vertical-align: top"><code>autoDetectChanges</code></td><td><p>Set whether the fixture should try to detect changes automatically.</p>
<p>When autodetect is true, the test fixture listens for <em>zone</em> events and calls <code>detectChanges</code>. 
You probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates 
when your test code modifies component property values directly.</p>
<p>The default is <code>false</code> and testers who prefer fine control over test behavior
tend to keep it <code>false</code>. </p>
<p>Calls <code>detectChanges</code> immediately which detects existing changes
and will trigger <code>ngOnInit</code> if the component has not yet been initialized.</p>
</td></tr><tr><td style="vertical-align: top"><code>checkNoChanges</code></td><td><p>Do a change detection run to make sure there are no pending changes.
Throws an exceptions if there are.</p>
</td></tr><tr><td style="vertical-align: top"><code>isStable</code></td><td><p>Return <code>true</code> if the fixture is currently <em>stable</em>.
Returns <code>false</code> if there are async tasks that have not completed.</p>
</td></tr><tr><td style="vertical-align: top"><code>whenStable</code></td><td><p>Returns a promise that resolves when the fixture is stable.</p>
<p>Hook that promise to resume testing after completion of asynchronous activity or 
asynchronous change detection.
See <a href="#when-stable">above</a></p>
</td></tr><tr><td style="vertical-align: top"><code>destroy</code></td><td><p>Trigger component destruction.</p>
</td></tr></table><a id="debugelement-details"></a><h3 id="_debugelement_"><em>DebugElement</em></h3>
<p>The <code>DebugElement</code> provides crucial insights into the component&#39;s DOM representation.</p>
<p>From the test root component&#39;s <code>DebugElement</code>, returned by <code>fixture.debugElement</code>, 
you can walk (and query) the fixture&#39;s entire element and component sub-trees.</p>
<div class="alert is-important"><p>The <em>DebugElement</em> is officially <em>experimental</em> and thus subject to change.
Consult the <a href="../api/core/index/DebugElement-class.html">API reference</a> for the latest status.</p>
</div><p>Here are the most useful <code>DebugElement</code> members for testers in approximate order of utility.</p>
<table><tr><th>Member</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>nativeElement</code></td><td><p>The corresponding DOM element in the browser (null for WebWorkers).</p>
</td></tr><tr><td style="vertical-align: top"><code>query</code></td><td><p>Calling <code>query(predicate: Predicate&lt;DebugElement&gt;)</code> returns the first <code>DebugElement</code>
that matches the <a href="#query-predicate">predicate</a> at any depth in the subtree.</p>
</td></tr><tr><td style="vertical-align: top"><code>queryAll</code></td><td><p>Calling <code>queryAll(predicate: Predicate&lt;DebugElement&gt;)</code> returns all <code>DebugElements</code>
that matches the <a href="#query-predicate">predicate</a> at any depth in subtree.</p>
</td></tr><tr><td style="vertical-align: top"><code>injector</code></td><td><p>The host dependency injector. 
For example, the root element&#39;s component instance injector.</p>
</td></tr><tr><td style="vertical-align: top"><code>componentInstance</code></td><td><p>The element&#39;s own component instance, if it has one.</p>
</td></tr><tr><td style="vertical-align: top"><code>context</code></td><td><p>An object that provides parent context for this element.
Often an ancestor component instance that governs this element.</p>
<p>When an element is repeated with in <code>*ngFor</code>, the context is an <code>NgForRow</code> whose <code>$implicit</code>
property is the value of the row instance value. 
For example, the <code>hero</code> in <code>*ngFor=&quot;let hero of heroes&quot;</code>.</p>
</td></tr><tr><td style="vertical-align: top"><code>children</code></td><td><p>The immediate <code>DebugElement</code> children. Walk the tree by descending through <code>children</code>.</p>
<div class="l-sub-section"><p><code>DebugElement</code> also has <code>childNodes</code>, a list of <code>DebugNode</code> objects. 
<code>DebugElement</code> derives from <code>DebugNode</code> objects and there are often 
more nodes than elements. Testers can usually ignore plain nodes.</p>
</div></td></tr><tr><td style="vertical-align: top"><code>parent</code></td><td><p>The <code>DebugElement</code> parent. Null if this is the root element.</p>
</td></tr><tr><td style="vertical-align: top"><code>name</code></td><td><p>The element tag name, if it is an element.</p>
</td></tr><tr><td style="vertical-align: top"><code>triggerEventHandler</code></td><td><p>Triggers the event by its name if there is a corresponding listener 
in the element&#39;s <code>listeners</code> collection.</p>
<p>If the event lacks a listner or there&#39;s some other problem, 
consider calling <code>nativeElement.dispatchEvent(eventObject)</code></p>
</td></tr><tr><td style="vertical-align: top"><code>listeners</code></td><td><p>The callbacks attached to the component&#39;s <code>@Output</code> properties and/or the element&#39;s event properties.</p>
</td></tr><tr><td style="vertical-align: top"><code>providerTokens</code></td><td><p>This component&#39;s injector lookup tokens.
Includes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</p>
</td></tr><tr><td style="vertical-align: top"><code>source</code></td><td><p>Where to find this element in the source component template.</p>
</td></tr><tr><td style="vertical-align: top"><code>references</code></td><td><p>Dictionary of objects associated with template local variables (e.g. <code>#foo</code>),
keyed by the local variable name.</p>
</td></tr></table><a id="query-predicate"></a><p>The <code>DebugElement.query(predicate)</code> and <code>DebugElement.queryAll(predicate)</code> methods take a
predicate that filters the source element&#39;s subtree for matching <code>DebugElement</code>.</p>
<p>The predicate is any method that takes a <code>DebugElement</code> and returns a <em>truthy</em> value.
The following example finds all <code>DebugElements</code> with a reference to a template local variable named &quot;content&quot;:</p>
<div class="code-example"><code-example language="ts" format="">// Filter for DebugElements with a #content reference
const contentRefs = el.queryAll( de =&gt; de.references[&#39;content&#39;]);
</code-example></div><p>The Angular <code>By</code> class has three static methods for common predicates:</p>
<ul>
<li><code>By.all</code> - return all elements</li>
<li><code>By.css(selector)</code> - return elements with matching CSS selectors.</li>
<li><code>By.directive(directive)</code> - return elements that Angular matched to an instance of the directive class. </li>
</ul>
<div class="code-example"><header><h4>app/hero/hero-list.component.spec.ts</h4></header><code-example language="ts" format="">// Can find DebugElement either by css selector or by directive
const h2        = fixture.debugElement.query(By.css(&#39;h2&#39;));
const directive = fixture.debugElement.query(By.directive(HighlightDirective));
</code-example></div><a id="renderer-tests"></a><p>Many custom application directives inject the <code>Renderer</code> and call one of its <code>set...</code> methods.</p>
<p>The test environment substitutes the <code>DebugDomRender</code> for the runtime <code>Renderer</code>.
The <code>DebugDomRender</code> updates additional dictionary properties of the <code>DebugElement</code>
when something calls a <code>set...</code> method.</p>
<p>These dictionary properties are primarily of interest to authors of Angular DOM inspection tools
but they may provide useful insights to testers as well.</p>
<table><tr><th>Dictionary</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>properties</code></td><td><p>Updated by <code>Renderer.setElementProperty</code>.
Many Angular directives call it, including <code>NgModel</code>.</p>
</td></tr><tr><td style="vertical-align: top"><code>attributes</code></td><td><p>Updated by <code>Renderer.setElementAttribute</code>.
Angular <code>[attribute]</code> bindings call it.</p>
</td></tr><tr><td style="vertical-align: top"><code>classes</code></td><td><p>Updated by <code>Renderer.setElementClass</code>.
Angular <code>[class]</code> bindings call it.</p>
</td></tr><tr><td style="vertical-align: top"><code>styles</code></td><td><p>Updated by <code>Renderer.setElementStyle</code>.
Angular <code>[style]</code> bindings call it.</p>
</td></tr></table><p>Here&#39;s an example of <code>Renderer</code> tests from the <live-example plnkr="bag-specs">live &quot;Specs Bag&quot; sample</live-example>.</p>
<div class="code-example"><code-example language="ts" format="">it(&#39;DebugDomRender should set attributes, styles, classes, and properties&#39;, () =&gt; {
  const fixture = TestBed.createComponent(BankAccountParentComponent);
  fixture.detectChanges();
  const comp = fixture.componentInstance;

  // the only child is debugElement of the BankAccount component
  const el = fixture.debugElement.children[0];
  const childComp = el.componentInstance as BankAccountComponent;
  expect(childComp).toEqual(jasmine.any(BankAccountComponent));

  expect(el.context).toBe(comp, &#39;context is the parent component&#39;);

  expect(el.attributes[&#39;account&#39;]).toBe(childComp.id, &#39;account attribute&#39;);
  expect(el.attributes[&#39;bank&#39;]).toBe(childComp.bank, &#39;bank attribute&#39;);

  expect(el.classes[&#39;closed&#39;]).toBe(true, &#39;closed class&#39;);
  expect(el.classes[&#39;open&#39;]).toBe(false, &#39;open class&#39;);

  expect(el.properties[&#39;customProperty&#39;]).toBe(true, &#39;customProperty&#39;);

  expect(el.styles[&#39;color&#39;]).toBe(comp.color, &#39;color style&#39;);
  expect(el.styles[&#39;width&#39;]).toBe(comp.width + &#39;px&#39;, &#39;width style&#39;);
});
</code-example></div><a href="#top" class="to-top">Back to top</a><div class="l hr"><a id="faq"> </a><div class="l-main-section"></div><h2 id="faq-frequently-asked-questions">FAQ: Frequently Asked Questions</h2>
</div><!--:marked
  General
  * [When are end-to-end (e2e) tests a good choice?](#q-when-e2e)
  * [When to use the _TestBed_?](#q-why-testbed)
  * [When to write vanilla tests without the _TestBed_?](#q-when-no-testbed)
  * [When can I skip _TestBed.compileComponents_?](#q-when-no-compile-components)
  * [Why must _TestBed.compileComponents_ be called last?](#q-why-compile-components-is-last)
  * [Why must _inject_ be called last?](#q-why-last-last)  
  * [What's the difference between _async_ and _fakeAsync_?](#q-async-vs-fake-async)
  * [What's the difference between _whenStable_ and _tick_?](#q-when-stable-vs-tick)
  * [How do I get something from the component's injector?](#q-component-injector)
  * [Why do feature modules make testing easier?](#q-why-feature-modules)  
  * [When should I prefer the _DynamicTestModule_?](#q-dynamic-test-module)
  * [How do I know if an injected service method was called?](#q-spy-on-service)
  * [When must I call _detectChanges_ and why?](#q-detect-changes)
  * [What's the difference between _triggerEventHandler_ and _dispatchEvent_?](#q-trigger-event-handler-vs-dispatch-event)
  * [How do I find an element by directive?](#q-by-directive)
  * [How do I extend Jasmine matchers?](#q-jasmine-matchers)
  * [Why would I add a test folder and how?](#q-test-folder)
  * [Why put specs next to the things they test?](#q-spec-file-location)
  * [When would I put specs in a test folder?](#q-specs-in-test-folder)
  * [How do I use the Jasmine HTML TestRunner in the browser?](#q-jasmine-browser-test-runner)

  Resources
  * [Where can I learn more about unit testing in JavaScript?](#q-js-unit-testing-resources)  
  * [Where can I learn more about testing with Jasmine?](#q-jasmine-resources)
  * [Where can I learn more about testing with karma?](#q-karma-resources)
  * [Where can I learn more about e2e testing with protractor?](#q-protractor-resources)

a(href="#top").to-top Back to top

.l-hr
--><a id="q-spec-file-location"></a><h3 id="why-put-specs-next-to-the-things-they-test-">Why put specs next to the things they test?</h3>
<p>We recommend putting unit test spec files in the same folder 
as the application source code files that they test because</p>
<ul>
<li>Such tests are easy to find</li>
<li>You see at a glance if a part of our application lacks tests.</li>
<li>Nearby tests can reveal how a part works in context. </li>
<li>When you move the source (inevitable), you remember to move the test.</li>
<li>When you rename the source file (inevitable), you remember to rename the test file.</li>
</ul>
<div class="l-hr"></div><a id="q-specs-in-test-folder"></a><h3 id="when-would-i-put-specs-in-a-test-folder-">When would I put specs in a test folder?</h3>
<p>Application integration specs can test the interactions of multiple parts
spread across folders and modules.
They don&#39;t really belong to part in particular so they don&#39;t have a
natural home next to any one file.</p>
<p>It&#39;s often better to create an appropriate folder for them in the <code>tests</code> directory.</p>
<p>Of course specs that test the test helpers belong in the <code>test</code> folder,
next to their corresponding helper files.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></article><div class="main-footer"><nav class="background-midnight grid-fluid"><div class="c3 main-footer-branding"><div class="logo-inverse-large"></div></div><div class="c2"><h3 class="text-headline">RESOURCES</h3><ul class="text-body"><!-- TODO: (ericjim) make a libraries page to showcase all angular 2 libraries--><!--li <a href="/libraries.html">Libraries</a>--><li><a href="/about/">About</a></li><li><a href="/resources/">Books & Training</a></li><li><a href="/resources/">Tools & Libraries</a></li><li><a href="/resources/">Community</a></li><li><a href="/presskit.html">Press Kit</a></li></ul></div><div class="c2"><h3 class="text-headline">HELP</h3><ul class="text-body"><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><a href="https://github.com/angular/angular/issues"> Report Issues</a></li><li><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> Site Feedback</a></li></ul></div><div class="c2"><h3 class="text-headline">COMMUNITY</h3><ul class="text-body"><li><a href="/events.html">Events</a></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="https://twitter.com/angularjs"> Twitter</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><a href="/contribute.html"> Contribute</a></li></ul></div><div class="c2"><h3 class="text-headline">LANGUAGES</h3><ul class="text-body"><li><a href="https://angular.cn/">中文版</a></li></ul></div></nav><footer class="background-midnight"><small class="text-caption">Powered by Google ©2010-2016. Code licensed under an <a href="/license" class="text-snow">MIT-style License</a>. Documentation licensed under <a class="text-snow" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</small><a aria-label="View Style Guide" href="/docs/ts/latest/styleguide.html" title="Style Guide" class="styleguide-trigger text-snow"><span class="icon-favorite"></span></a></footer></div><!-- VENDORS --><script src="/resources/js/vendor/prettify.js"></script><script src="/resources/js/vendor/lang-basic.js"></script><script src="/resources/js/vendor/lang-dart.js"></script><script src="/resources/js/vendor/lodash.js"></script><script src="/resources/js/vendor/clipboard.min.js"></script><!-- Angular Material Dependencies --><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-aria.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.js"></script><!-- Firebase -->
<script src="https://cdn.firebase.com/js/client/2.2.4/firebase.js"></script>
<!-- AngularFire -->
<script src="https://cdn.firebase.com/libs/angularfire/1.2.0/angularfire.min.js"></script>
<!-- Angular.io Site JS --><script src="/resources/js/site.js"></script><script src="/resources/js/util.js"></script><script src="/resources/js/controllers/app-controller.js"></script><script src="/resources/js/controllers/resources-controller.js"></script><script src="/resources/js/directives/cheatsheet.js"></script><script src="/resources/js/directives/api-list.js"></script><script src="/resources/js/directives/bio.js"></script><script src="/resources/js/directives/bold.js"></script><script src="/resources/js/directives/announcement-bar.js"></script><script src="/resources/js/directives/code.js"></script><script src="/resources/js/directives/copy.js"></script><script src="/resources/js/directives/code-tabs.js"></script><script src="/resources/js/directives/code-pane.js"></script><script src="/resources/js/directives/code-example.js"></script><script src="/resources/js/directives/if-docs.js"></script><script src="/resources/js/directives/live-example.js"></script><script src="/resources/js/directives/ngio-ex-path.js"></script><script src="/resources/js/directives/scroll-y-offset-element.js"></script><!-- GA --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-8594346-15', 'auto');
ga('send', 'pageview')

</script><!-- SWIFTYPE --><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

_st('install','VsuU7kH5Hnnj9tfyNvfK');
</script><!-- Google Feedback --><script src="//www.gstatic.com/feedback/api.js" type="text/javascript"></script><!-- Twitter Widget --><script>(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}})(document,"script","twitter-wjs");</script></body></html>