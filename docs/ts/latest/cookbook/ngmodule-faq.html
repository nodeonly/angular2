<!DOCTYPE html><html lang="en" ng-app="angularIOApp" itemscope itemtype="http://schema.org/Framework"><!-- template: public/docs/_layout--><head><title>Angular Module FAQs - ts</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta name="keywords" content="Angular, AngularJS, AngularDart, Javscript, Dart, Framework, JavaScript MVC, Google"/><meta name="robots" content="all"/><meta name="referrer" content="origin"/><meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Angular 2"/><meta property="og:image" content="/resources/images/logos/standard/shield-large.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="184"/><meta property="og:image:height" content="200"/><meta property="og:description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="name" content="Angular 2"/><meta itemprop="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="image" content="https://angular.io/resources/images/logos/standard/shield-large.png"/><link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico"/><link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,300,500,400italic,700" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/><link rel="stylesheet" href="/resources/css/vendor/icomoon/style.css"/><link rel="stylesheet" href="/resources/css/vendor/animate.css"/><link rel="stylesheet" href="/resources/css/main.css"/><!-- MOBILE ICONS -->
<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/resources/images/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/resources/images/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-194x194.png" sizes="194x194">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/resources/images/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/resources/images/favicons/manifest.json"></head><body ng-controller="AppCtrl as appCtrl" class="l-offset-nav l-offset-side-nav"><nav scroll-y-offset-element="scroll-y-offset-element" class="main-nav l-pinned-top l-layer-5"><h1><a href="/" md-button>Angular <sup>by Google</sup></a></h1><button aria-label="View Menu" ng-click="appCtrl.toggleMainMenu($event)" md-button="md-button" class="main-nav-button main-nav-mobile-trigger l-right">Site Menu <span class="icon icon-arrow-drop-down"></span></button><ul ng-class="appCtrl.showMainNav ? 'is-visible' : ''"><li class="l-left"><a class="main-nav-button" href="/features.html" md-button>Features</a></li><li class="l-left"><a class="main-nav-button" href="/docs/ts/latest/" md-button>Docs</a></li><li class="l-left"><a class="main-nav-button" href="/events.html" md-button>Events</a></li><li class="l-left"><a class="main-nav-button" href="/news.html" md-button>News</a></li><li class="l-right"><a class="main-nav-button" href="/docs/ts/latest/quickstart.html" md-button>Get Started</a></li></ul></nav><!-- Include this file ONLY when current.path[2] is defined--><nav ng-class="appCtrl.showDocsNav ? 'is-visible' : ''" class="sidenav l-pinned-left l-layer-4 l-offset-nav"><!-- SEARCH BAR--><header class="sidenav-search st-input-wrapper"><form class="st-input-inner"><label for="search-io" class="is-hidden">Search Docs</label><input type="search" id="search-io" placeholder="SEARCH DOCS..."/></form><button aria-label="View Docs Menu" ng-click="appCtrl.toggleDocsMenu($event)" md-button="md-button" class="mobile-trigger button">Docs <span class="icon icon-arrow-drop-down"></span></button></header><ul class="sidenav-links"><li class="sidenav-section no-border"><a href="/docs/ts/latest/" class="nav-title">Docs Home</a></li><!-- CORE DOCUMENTATION--><li class="sidenav-section-divider"><h3>Core Documentation</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/quickstart.html" title="Get up and running with Angular 2" class="nav-title ">Quickstart</a></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/" title="How to read and use this documentation" class="nav-title is-parent ">Guide<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/" title="How to read and use this documentation">1. Overview</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/architecture.html" title="The basic building blocks of Angular 2 applications">2. Architecture</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/displaying-data.html" title="Interpolation and other forms of property binding help us show app data in the UI.">3. Displaying Data</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/user-input.html" title="User input triggers DOM events. We listen to those events with event bindings that funnel updated values back into our components and models.">4. User Input</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/forms.html" title="A form creates a cohesive, effective, and compelling data entry experience. An Angular form coordinates a set of data-bound user controls, tracks changes, validates input, and presents errors.">5. Forms</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/dependency-injection.html" title="Angular's dependency injection system creates and delivers dependent services &quot;just-in-time&quot;.">6. Dependency Injection</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/template-syntax.html" title="Learn how to write templates that display data and consume user events with the help of data binding.">7. Template Syntax</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/cheatsheet.html" title="A quick guide to Angular syntax. (Content is provisional and may change.)">8. Angular Cheat Sheet</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/style-guide.html" title="Write Angular 2 with style.">9. Style Guide</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/glossary.html" title="Brief definitions of the most important words in the Angular 2 vocabulary">10. Glossary</a></li></ul></div></li><li class="sidenav-section no-border"><a href="/docs/ts/latest/api/" title="API Preview" class="nav-title ">API Reference</a></li><!-- ADVANCED DOCUMENATION--><li class="sidenav-section-divider"><h3>Additional Documentation</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/tutorial/" title="The Tour of Heroes tutorial takes us through the steps of creating an Angular application in TypeScript." class="nav-title is-parent ">Tutorial<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/" title="The Tour of Heroes tutorial takes us through the steps of creating an Angular application in TypeScript.">1. Introduction</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt1.html" title="We build a simple hero editor">2. The Hero Editor</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt2.html" title="We build a master/detail page with a list of heroes">3. Master/Detail</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt3.html" title="We refactor the master/detail view into separate components">4. Multiple Components</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt4.html" title="We create a reusable service to manage our hero data calls">5. Services</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt5.html" title="We add the Angular Component Router and learn to navigate among the views">6. Routing</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt6.html" title="We convert our service and components to use Angular's HTTP service">7. HTTP</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/ngmodule.html" title="Define application modules with @NgModule" class="nav-title is-parent ">Advanced Documentation<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/ngmodule.html" title="Define application modules with @NgModule">Angular Modules (NgModule)</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/animations.html" title="A guide to Angular's animation system.">Animations</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/attribute-directives.html" title="Attribute directives attach behavior to elements.">Attribute Directives</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/browser-support.html" title="Browser support and polyfills guide.">Browser support</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/component-styles.html" title="Learn how to apply CSS styles to components.">Component Styles</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/hierarchical-dependency-injection.html" title="Angular's hierarchical dependency injection system supports nested injectors in parallel with the component tree.">Hierarchical Injectors</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/server-communication.html" title="Talk to a remote server with an HTTP Client.">HTTP Client</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/lifecycle-hooks.html" title="Angular calls lifecycle hook methods on directives and components as it creates, changes, and destroys them.">Lifecycle Hooks</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/npm-packages.html" title="Recommended npm packages, and how to specify package dependencies">Npm Packages</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/pipes.html" title="Pipes transform displayed values within a template.">Pipes</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/router.html" title="Discover the basics of screen navigation with the Angular 2 Router.">Routing &amp; Navigation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/security.html" title="Developing for content security in Angular applications">Security</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/structural-directives.html" title="Angular has a powerful template engine that lets us easily manipulate the DOM structure of our elements.">Structural Directives</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/testing.html" title="Techniques and practices for testing an Angular 2 app">Testing</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/typescript-configuration.html" title="TypeScript configuration for Angular 2 developers">TypeScript Configuration</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/upgrade.html" title="Angular 1 applications can be incrementally upgraded to Angular 2.">Upgrading from 1.x</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/webpack.html" title="Create your Angular 2 applications with a Webpack based tooling">Webpack: an introduction</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/cookbook/" title="A collection of recipes for common Angular application scenarios" class="nav-title is-parent is-selected">Cookbook<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists"><ul><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/" title="A collection of recipes for common Angular application scenarios">Overview</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/aot-compiler.html" title="Learn how to use Ahead-of-time compilation">Ahead-of-Time Compilation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/a1-a2-quick-reference.html" title="Learn how Angular 1 concepts and techniques map to Angular 2">Angular 1 to 2 Quick Ref</a></li><li class="nav-list-item is-selected"><a href="/docs/ts/latest/cookbook/ngmodule-faq.html" title="Answers to frequently asked questions about @NgModule">Angular Module FAQs</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-communication.html" title="Share information between different directives and components">Component Interaction</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-relative-paths.html" title="Use relative URLs for component templates and styles.">Component-relative Paths</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dependency-injection.html" title="Techniques for Dependency Injection">Dependency Injection</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-form.html" title="Render dynamic forms with FormGroup">Dynamic Forms</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/form-validation.html" title="Validate user's form entries">Form Validation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/rc4-to-rc5.html" title="Migrate your RC4 app to RC5 in minutes.">RC4 to RC5 Migration</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/set-document-title.html" title="Setting the document or window title using the Title service.">Set the Document Title</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ts-to-js.html" title="Convert Angular 2 TypeScript examples into ES5 JavaScript">TypeScript to JavaScript</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/visual-studio-2015.html" title="Use Visual Studio 2015 with the QuickStart files">Visual Studio 2015 QuickStart</a></li></ul></div></li></ul><!-- DROPDOWN BUTTON --><nav class="dropdown"><button aria-label="Select a version of Angular" md-button="md-button" ng-click="appCtrl.toggleVersionMenu($event)" class="dropdown-button">Angular 2 for TypeScript  <span class="icon icon-arrow-drop-down"></span></button><div ng-click="appCtrl.toggleVersionMenu($event)" ng-show="appCtrl.showMenu" class="overlay ng-hide"></div><!-- DROPDOWN MENU --><ul ng-class="appCtrl.showMenu ? 'is-visible' : ''" class="dropdown-menu"><li><a href="/docs/ts/latest/cookbook/ngmodule-faq.html" md-button>Angular 2 for TypeScript </a></li><li><a href="/docs/js/latest/cookbook/ngmodule-faq.html" md-button>Angular 2 for JavaScript </a></li><li><a href="/docs/dart/latest/cookbook/ngmodule-faq.html" md-button>Angular 2 for Dart </a></li></ul></nav></nav><script>// Could put in appCtrl but only needed here and clear here
(function scrollToSelectedLink() {
  var sideNav = document.getElementsByClassName('sidenav')[0];
  var link = sideNav.getElementsByClassName('is-selected')[0];
  if(link && link.offsetTop > window.innerHeight){
    sideNav.scrollTop = link.offsetTop - (window.innerHeight/2);
    //alert("offsetTop: " + link.offsetTop + " side-nav top is " + sideNav.scrollTop);
  }
})()</script><!-- template: public/_includes/_hero--><header class="hero background-sky"><h1 class="hero-title ">Angular Module FAQs</h1><!--CLEAR FLOAT ELEMENTS--><div class="clear"></div></header><div class="banner"><p class="text-body">Answers to frequently asked questions about @NgModule</p></div><article class="l-content-small grid-fluid docs-content"><script>function why(id, backTo) {
  var id = "#"+id;
  var el = document.querySelector(id);
  el.hidden=el.hidden=!el.hidden;

  if (el.hidden && backTo){
    // the next line is required to work around a bug in WebKit (Chrome / Safari)
    location.href = "#";
    location.href =  "#" + backTo;
  }
}</script><script>function verbose(isVerbose) {
  isVerbose = !! isVerbose;
  var el = document.querySelector('button.verbose.off');
  el.style.display = isVerbose ? 'block' : 'none';
  var el = document.querySelector('button.verbose.on');
  el.style.display = isVerbose ? 'none' : 'block';

  CCSStylesheetRuleStyle('main','.l-verbose-section', 'display',
    isVerbose ? 'block' : 'none');
}
</script><script>function CCSStylesheetRuleStyle(stylesheet, selectorText, style, value){
  /* returns the value of the element style of the rule in the stylesheet
  *  If no value is given, reads the value
  *  If value is given, the value is changed and returned
  *  If '' (empty string) is given, erases the value.
  *  The browser will apply the default one
  *
  * string stylesheet: part of the .css name to be recognized, e.g. 'default'
  * string selectorText: css selector, e.g. '#myId', '.myClass', 'thead td'
  * string style: camelCase element style, e.g. 'fontSize'
  * string value optional : the new value
  */
  var CCSstyle = undefined, rules, sheet;
  for(var m in document.styleSheets){
    sheet = document.styleSheets[m];
    if(sheet.href && sheet.href.indexOf(stylesheet) != -1){
    rules = sheet[document.all ? 'rules' : 'cssRules'];
    for(var n in rules){
      console.log(rules[n].selectorText);
      if(rules[n].selectorText == selectorText){
        CCSstyle = rules[n].style;
        break;
      }
    }
    break;
    }
  }
  if(value == undefined)
    return CCSstyle[style]
  else
    return CCSstyle[style] = value
}
</script><h1 id="faqs">FAQs</h1>
<p><strong>Angular Modules</strong> help organize an application into cohesive blocks of functionality.</p>
<p>The <a href="../guide/ngmodule.html">Angular Modules chapter</a> covers the concepts and takes you step by step
from the most elementary <code>@NgModule</code> to a multi-faceted sample with lazy loaded modules.</p>
<p><em>This</em> chapter answers the questions many developers ask about Angular Module design and implementation.</p>
<div class="alert is-important"><p>These FAQs assume that you have already read the <a href="../guide/ngmodule.html">Angular Module</a> chapter.</p>
</div><p>Declarations</p>
<ul>
<li><a href="#q-what-to-declare">What classes should I add to <em>declarations</em>?</a></li>
<li><a href="#q-declarable">What is a <em>declarable</em>?</a></li>
<li><a href="#q-what-not-to-declare">What classes should I <em>not</em> add to <em>declarations</em>?</a></li>
<li><a href="#q-why-multiple-mentions">Why list the same component in multiple <em>NgModule</em> properties?</a></li>
<li><a href="#q-why-cant-bind-to">What does &quot;<em>Can&#39;t bind to &#39;x&#39; since it isn&#39;t a known property of &#39;y&#39;</em>&quot; mean?</a></li>
</ul>
<p>Imports</p>
<ul>
<li><a href="#q-what-to-import">What should I import?</a></li>
<li><a href="#q-browser-vs-common-module">Should I import <em>BrowserModule</em> or <em>CommonModule</em>?</a></li>
<li><a href="#q-reimport">What if I import the same module twice?</a></li>
</ul>
<p>Exports  </p>
<ul>
<li><a href="#q-what-to-export">What should I export?</a></li>
<li><a href="#q-what-not-to-export">What should I <em>not</em> export?</a></li>
<li><a href="#q-re-export">Can I re-export imported classes and modules?</a></li>
<li><a href="#q-for-root">What is the <em>forRoot</em> method?</a></li>
</ul>
<p>Service Providers</p>
<ul>
<li><a href="#q-module-provider-visibility">Why is a service provided in a feature module visible everywhere?</a></li>
<li><a href="#q-lazy-loaded-module-provider-visibility">Why is a service provided in a <em>lazy loaded</em> module visible only to that module?</a></li>
<li><a href="#q-module-provider-duplicates">What if two modules provide the <em>same</em> service?</a></li>
<li><a href="#q-component-scoped-providers">How do I restrict service scope to a module?</a></li>
<li><a href="#q-root-component-or-module">Should I add app-wide providers to the root <em>AppModule</em> or the root <em>AppComponent</em>?</a></li>
<li><a href="#q-component-or-module">Should I add other providers to a module or a component?</a></li>
<li><a href="#q-why-bad">Why is it bad if <em>SharedModule</em> provides a service to a lazy loaded module?</a></li>
<li><a href="#q-why-child-injector">Why does lazy loading create a child injector?</a>  </li>
<li><a href="#q-is-it-loaded">How can I tell if a module or service was previously loaded?</a></li>
</ul>
<p>Entry Components</p>
<ul>
<li><a href="#q-entry-component-defined">What is an <em>entry component</em>?</a></li>
<li><a href="#q-bootstrap_vs_entry_component">What is the difference between a <em>bootstrap</em> component and an <em>entry component</em>?</a></li>
<li><a href="#q-when-entry-components">When do I add components to <em>entryComponents</em>?</a></li>
<li><a href="#q-why-entry-components">Why does Angular need <em>entryComponents</em>?</a></li>
</ul>
<p>General</p>
<ul>
<li><a href="#q-module-recommendations">What kinds of modules should I have and how should I use them?</a></li>
<li><a href="#q-ng-vs-js-modules">What&#39;s the difference between Angular and JavaScript Modules?</a></li>
<li><a href="#q-template-reference">What is a &quot;template reference&quot;?</a></li>
<li><a href="#q-template-reference">How does Angular find components, directives, and pipes in a template?</a>  </li>
<li><a href="#q-angular-compiler">What is the Angular Compiler?</a></li>
<li><a href="#q-ngmodule-api">Can you summarize the <em>NgModule</em> API?</a></li>
</ul>
<div class="l-hr"></div><a id="q-what-to-declare"></a><div class="l-main-section"></div><h3 id="what-classes-should-i-add-to-_declarations_-">What classes should I add to <em>declarations</em>?</h3>
<p>Add <a href="#q-declarable">declarable</a> classes &mdash; components, directives, and pipes &mdash; to a <code>declarations</code> list.</p>
<p>These classes must be declared in <em>exactly one</em> module of the application.
Declare them in <em>this</em> module if they <em>belong</em> to this module.</p>
<div class="l-hr"></div><a id="q-declarable"></a><div class="l-main-section"></div><h3 id="what-is-a-_declarable_-">What is a <em>declarable</em>?</h3>
<p><em>Declarables</em> are the class types &mdash; components, directives, and pipes &mdash;
that you can add to a module&#39;s <code>declarations</code> list. 
They&#39;re the <em>only</em> classes that you can add to <code>declarations</code>.</p>
<div class="l-hr"></div><a id="q-what-not-to-declare"></a><div class="l-main-section"></div><h3 id="what-classes-should-i-_not_-add-to-_declarations_-">What classes should I <em>not</em> add to <em>declarations</em>?</h3>
<p>Only <a href="#q-declarable">declarable</a> classes can be added to a module&#39;s <code>declarations</code> list.</p>
<p>Do <em>not</em> declare </p>
<ul>
<li><p>a class that is already declared in another module, whether an app module, @angular module, or 3rd party module</p>
</li>
<li><p>an array of directives imported from another module. 
For example, do not declare FORMS_DIRECTIVES from <code>@angular/forms</code>.</p>
</li>
<li><p>module classes</p>
</li>
<li><p>service classes</p>
</li>
<li><p>non-Angular classes and objects such as 
strings, numbers, functions, entity models, configurations, business logic, and helper classes.</p>
</li>
</ul>
<div class="l-hr"></div><a id="q-why-multiple-mentions"></a><div class="l-main-section"></div><h3 id="why-list-the-same-component-in-multiple-_ngmodule_-properties-">Why list the same component in multiple <em>NgModule</em> properties?</h3>
<p>We often see <code>AppComponent</code> listed in both <code>declarations</code> and <code>bootstrap</code>.
We might see <code>HeroComponent</code> listed in <code>declarations</code>, <code>exports</code>, and <code>entryComponents</code>.</p>
<p>That <em>feels</em> redundant but these properties have different functions 
and we can&#39;t infer that membership in one list implies membership in another list.</p>
<ul>
<li><code>AppComponent</code> could be declared in this module but not bootstrapped.</li>
<li><code>AppComponent</code> could be bootstrapped in this module but declared in a different feature module.</li>
<li><code>HeroComponent</code> could be imported from another app module (so we can&#39;t declare it) and re-exported by this module.</li>
<li><code>HeroComponent</code> could be exported for inclusion in an external component&#39;s template and also dynamically loaded in a pop-up dialog.</li>
</ul>
<div class="l-hr"></div><a id="q-why-cant-bind-to"></a><div class="l-main-section"></div><h3 id="what-does-_can-t-bind-to-x-since-it-isn-t-a-known-property-of-y-_-mean-">What does &quot;<em>Can&#39;t bind to &#39;x&#39; since it isn&#39;t a known property of &#39;y&#39;</em>&quot; mean?</h3>
<p>This error usually means either that you neglected to declare the directive &quot;x&quot; 
or you haven&#39;t imported the module to which &quot;x&quot; belongs.</p>
<p>For example, if &quot;x&quot; is <code>ngModel</code>, you probably haven&#39;t imported the <code>FormsModule</code> from <code>@angular/forms</code>.</p>
<p>Perhaps you declared &quot;x&quot; in an application sub-module but forgot to export it? 
The &quot;x&quot; class won&#39;t be visible to other modules until you add it to the <code>exports</code> list.</p>
<div class="l-hr"></div><a id="q-what-to-import"></a><div class="l-main-section"></div><h3 id="what-should-i-import-">What should I import?</h3>
<p>Import modules whose public (exported) <a href="#q-declarable">declarable classes</a> 
you need to reference in this module&#39;s component templates.</p>
<p>This invariably means importing <code>CommonModule</code> from <code>@angular/common</code> for access to
the Angular directives such as <code>NgIf</code> and <code>NgFor</code>. 
You can import it directly or from another module that <a href="#q-reexport">re-exports</a> it.</p>
<p>Import <code>FormsModule</code> from <code>@angular/forms</code> 
if your components have <code>[(ngModel)]</code> two-way binding expressions.</p>
<p>Import <em>shared</em> and <em>feature</em> modules when this module&#39;s components incorporate their
components, directives, and pipes.</p>
<p>Only <a href="#q-browser-vs-common-module">import <em>BrowserModule</em></a> in the root <code>AppModule</code>.</p>
<div class="l-hr"></div><a id="q-browser-vs-common-module"></a><div class="l-main-section"></div><h3 id="should-i-import-_browsermodule_-or-_commonmodule_-">Should I import <em>BrowserModule</em> or <em>CommonModule</em>?</h3>
<p>The <strong>root application module</strong> (<code>AppModule</code>) of almost every browser application
should import <code>BrowserModule</code> from <code>@angular/platform-browser</code>.</p>
<p><code>BrowserModule</code> provides services that are essential to launch and run a browser app.</p>
<p><code>BrowserModule</code> also re-exports <code>CommonModule</code> from <code>@angular/common</code>
which means that component in the <code>AppModule</code> module also have access to
the Angular directives every app needs such as <code>NgIf</code> and <code>NgFor</code>.</p>
<p><em>Do not import</em> <code>BrowserModule</code> in any other module.
<em>Feature modules</em> and <em>lazy loaded modules</em> should import <code>CommonModule</code> instead.
They need the common directives. They don&#39;t need to re-install the app-wide providers. </p>
<div class="l-sub-section"><p><code>BrowserModule</code> throws an error if you try to lazy load  a module that imports it.</p>
</div><p>Importing <code>CommonModule</code> also frees feature modules for use on <em>any</em> target platform, not just browsers,
a fact of some interest to authors of cross-platform libraries.</p>
<div class="l-hr"> </div><a id="q-reimport"></a><div class="l-main-section"></div><h3 id="what-if-i-import-the-same-module-twice-">What if I import the same module twice?</h3>
<p>That&#39;s not a problem. When three modules all import Module &#39;A&#39;, 
Angular evaluates Module &#39;A&#39; once, the first time it encounters it, and does not do so again. </p>
<p>That&#39;s true at whatever level <code>A</code> appears in a hierarchy of imported modules.
When Module &#39;B&#39; imports Module &#39;A&#39;, Module &#39;C&#39; imports &#39;B&#39;, and Module &#39;D&#39; imports <code>[C, B, A]</code>,
then &#39;D&#39; triggers the evaluation of &#39;C&#39; which triggers the evaluation of &#39;B&#39; which evaluates &#39;A&#39;.
When Angular gets to the &#39;B&#39; and &#39;A&#39; in &#39;D&#39;, they&#39;re already cached and ready to go.</p>
<p>Angular does not like modules with circular references so don&#39;t let Module &#39;A&#39; import Module &#39;B&#39; which imports Module &#39;A&#39;.</p>
<div class="l-hr"> </div><a id="q-what-to-export"></a><div class="l-main-section"></div><h3 id="what-should-i-export-">What should I export?</h3>
<p>Export <a href="#q-declarable">declarable</a> classes that components in <em>other</em> modules
should be able to reference in their templates. These are your <em>public</em> classes.
If you don&#39;t export a class, it stays <em>private</em>, visible only to other component
declared in this module.</p>
<p>You <em>can</em> export any declarable class &mdash; components, directives, and pipes &mdash; 
whether it is declared in this module or in an imported module.</p>
<p>You <em>can</em> re-export entire imported modules which effectively re-exports all of their exported classes.
A module can even export a module that it doesn&#39;t import. </p>
<div class="l-hr"></div><a id="q-what-not-to-export"></a><div class="l-main-section"></div><h3 id="what-should-i-not-export-">What should I <em>not</em> export?</h3>
<p>Do <em>not</em> export</p>
<ul>
<li><p>Private components, directives, and pipes that you need only within components declared in this module.
If you don&#39;t want another module to see it, don&#39;t export it.</p>
</li>
<li><p>Non-declarable objects such as services, functions, configurations, entity models, etc.</p>
</li>
<li><p>Components that are only loaded dynamically by the router or by bootstrapping.
Such <a href="#q-entry-component-defined">entry components</a> can never be selected in another component&#39;s template.
There&#39;s no harm in exporting them but no benefit either. </p>
</li>
<li><p>Pure service modules that don&#39;t have public (exported) declarations. 
For example, there is no point in re-exporting <code>HttpModule</code> because it doesn&#39;t export anything.
It&#39;s only purpose is to add http service providers to the application as a whole.</p>
</li>
</ul>
<div class="l-hr"></div><a id="q-reexport"></a><a id="q-re-export"></a><div class="l-main-section"></div><h3 id="can-i-re-export-classes-and-modules-">Can I re-export classes and modules?</h3>
<p>Absolutely!</p>
<p>Modules are a great way to selectively aggregate classes from other modules and
re-export them in a consolidated, convenience module.</p>
<p>A module can re-export entire modules which effectively re-exports all of their exported classes.
Angular&#39;s own <code>BrowserModule</code> exports a couple of modules like this:</p>
<code-example>exports: [CommonModule, ApplicationModule]
</code-example><p>A module can export a combination of its own declarations, selected imported classes, and imported modules.</p>
<div class="l-sub-section"><p>Don&#39;t bother re-exporting pure service modules.
Pure service modules don&#39;t export <a href="#q-declarable">declarable</a> classes that another module could use.
For example, there is no point in re-exporting <code>HttpModule</code> because it doesn&#39;t export anything.
It&#39;s only purpose is to add http service providers to the application as a whole.</p>
</div><div class="l-hr"></div><a id="q-for-root"></a><div class="l-main-section"></div><h3 id="what-is-the-_forroot_-method-">What is the <em>forRoot</em> method?</h3>
<p>The <code>forRoot</code> static method is a convention that makes it easy for developers to configure the module&#39;s provider(s).</p>
<p>The <code>RouterModule.forRoot</code> method is a good example. 
Apps pass a <code>Routes</code> object to <code>RouterModule.forRoot</code> in order to configure the app-wide <code>Router</code> service with routes. 
<code>RouterModule.forRoot</code> returns a <a href="../api/core/index/ModuleWithProviders-interface.html">ModuleWithProviders</a>. 
We add that result to the <code>imports</code> list of the root <code>AppModule</code>.</p>
<div class="alert is-important"><p>Only call and import a <code>.forRoot</code> result in the root application module, <code>AppModule</code>.
Importing it in any other module, particularly in a lazy loaded module,
is contrary to the intent and is likely to produce a runtime error.</p>
</div><p><code>RouterModule</code> also offers a <code>forChild</code> static method for configuring the routes of lazy loaded modules.</p>
<p><strong><em>forRoot</em></strong> and <strong><em>forChild</em></strong> are conventional names for methods that
configure services in root and feature modules respectively.</p>
<p>Angular doesn&#39;t recognize these names but Angular developers do.
Follow this convention when you write similar modules with configurable service providers.</p>
<div class="l-hr"></div><a id="q-module-provider-visibility"></a><div class="l-main-section"></div><h3 id="why-is-a-service-provided-in-a-feature-module-visible-everywhere-">Why is a service provided in a feature module visible everywhere?</h3>
<p>Providers listed in the <code>@NgModule.providers</code> of a bootstrapped module have <strong>application scope</strong>.
Adding a service provider to <code>@NgModule.providers</code> effectively publishes the service to the entire application.</p>
<p>When we import a module,
Angular adds the module&#39;s service providers (the contents of its <code>providers</code> list)
to the application <em>root injector</em>.</p>
<p>This makes the provider visible to every class in the application that knows the provider&#39;s lookup token.</p>
<p>This is by design. 
Extensibility through module imports is a primary goal of the Angular module system.
Merging module providers into the application injector
makes it easy for a module library to enrich the entire application with new services.
By adding the <code>HttpModule</code> once, every application component can make http requests. </p>
<p>However, this can feel like an unwelcome surprise if you are expecting the module&#39;s services 
to be visible only to the components declared by that feature module.
If the <code>HeroModule</code> provides the <code>HeroService</code> and the root <code>AppModule</code> imports <code>HeroModule</code>, 
any class that knows the <code>HeroService</code> <em>type</em> can inject that service, 
not just the classes declared in the <code>HeroModule</code>.</p>
<div class="l-hr"></div><a id="q-lazy-loaded-module-provider-visibility"></a><div class="l-main-section"></div><h3 id="why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module-">Why is a service provided in a lazy loaded module visible only to that module?</h3>
<p>Unlike providers of the modules loaded at launch, 
providers of lazy loaded modules are <em>module-scoped</em>.</p>
<p>When the Angular router lazy-loads a module, it creates a new execution context.
That <a href="#q-why-child-injector" title="Why Angular creates a child injector">context has its own injector</a> which is a direct child of the application injector.</p>
<p>The router adds the lazy module&#39;s providers and the providers of its imported modules to this child injector.</p>
<p>These providers are insulated from changes to application providers with the same lookup token.
When the router creates a component within the lazy loaded context,
Angular prefers service instances created from these providers to the service instances of the application root injector.</p>
<div class="l-hr"></div><a id="q-module-provider-duplicates"></a><div class="l-main-section"></div><h3 id="what-if-two-modules-provide-the-_same_-service-">What if two modules provide the <em>same</em> service?</h3>
<p>When two imported modules, loaded at the same time, list a provider with the same token, 
the second module&#39;s provider &quot;wins&quot;. That&#39;s because both providers are added to the same injector.</p>
<p>When Angular looks to inject a service for that token, 
it creates and delivers the instance created by the second provider.</p>
<p><em>Every</em> class that injects this service gets the instance created by the second provider.
Even classes declared within the first module get the instance created by the second provider.
<em>This can be an unwelcome surprise</em>.</p>
<p>If Module A provides a service for token &#39;X&#39; and imports a module B
that also provides a service for token &#39;X&#39;, then Module A&#39;s service definition &quot;wins&quot;.</p>
<p>The service provided by the root <code>AppModule</code> takes precedence over services provided by imported modules.
The <code>AppModule</code> always wins.</p>
<div class="l-hr"></div><a id="q-component-scoped-providers"></a><div class="l-main-section"></div><h3 id="how-do-i-restrict-service-scope-to-a-module-">How do I restrict service scope to a module?</h3>
<p>When a module is loaded at application launch,
its <code>@NgModule.providers</code> have <strong><em>application-wide scope</em></strong>.
They are available for injection throughout the application.</p>
<p>Imported providers are easily replaced by providers from another imported module.
Such replacement may be by design. It could be unintentional and have adverse consequences.</p>
<div class="alert is-important"><p>As a general rule, import modules with providers <em>exactly once</em>, preferably in the application&#39;s <em>root module</em>.
That&#39;s also usually the best place to configure, wrap, and override them.</p>
</div><p>Suppose a module requires a customized <code>HttpBackend</code> that adds a special header for all Http requests.
If another module elsewhere in the application also customizes <code>HttpBackend</code>
or merely imports the <code>HttpModule</code>, it could override this module&#39;s <code>HttpBackend</code> provider, 
losing the special header. The server will reject http requests from this module.</p>
<div class="alert is-important"><p>Avoid this problem by importing the <code>HttpModule</code> only in the <code>AppModule</code>, the application <em>root module</em>.</p>
</div><p>If you must guard against this kind of &quot;provider corruption&quot;, <em>don&#39;t rely on a launch-time module&#39;s <code>providers</code>.</em></p>
<p>Load the module lazily if you can. 
Angular gives a <a href="#q-lazy-loaded-module-provider-visibility">lazy-loaded module</a> its own child injector.
The module&#39;s providers are visible only within the component tree created with this injector.</p>
<p>If you must load the module eagerly, when the application starts,
<strong><em>provide the service in a component instead.</em></strong></p>
<p>Continuing with the same example, suppose the components of a module truly require a private, custom <code>HttpBackend</code>.</p>
<p>Create a &quot;top component&quot; that acts as the root for all of the module&#39;s components. 
Add the custom <code>HttpBackend</code> provider to the top component&#39;s <code>providers</code> list rather than the module&#39;s <code>providers</code>.
Recall that Angular creates a child injector for each component instance and populates the injector
with the component&#39;s own providers.</p>
<p>When a child of this component <em>asks</em> for the <code>HttpBackend</code> service,
Angular provides the local <code>HttpBackend</code> service, 
not the version provided in the application root injector.
Child components will make proper http requests no matter what other modules do to <code>HttpBackend</code>.</p>
<p>Be sure to create module components as children of this module&#39;s top component.</p>
<p>You can embed the child components in the top component&#39;s template.
Alternatively, make the top component a routing host by giving it a <code>&lt;router-outlet&gt;</code>.
Define child routes and let the router load module components into that outlet.</p>
<div class="l-hr"></div><a id="q-root-component-or-module"></a><div class="l-main-section"></div><h3 id="should-i-add-app-wide-providers-to-the-root-_appmodule_-or-the-root-_appcomponent_-">Should I add app-wide providers to the root <em>AppModule</em> or the root <em>AppComponent</em>?</h3>
<div class="alert is-helpful"><p>Register application-wide providers in the root <code>AppModule</code>, not in the <code>AppComponent</code>.</p>
</div><p>Lazy-loaded modules and their components can inject <code>AppModule</code> services;
they cannot inject <code>AppComponent</code> services.</p>
<p>Register a service in <code>AppComponent</code> providers <em>only</em> if the service must be hidden
from components outside the <code>AppComponent</code> tree. This is a rare exceptional use case.</p>
<p>More generally, <a href="#q-component-or-module">prefer registering providers in modules</a> to registering in components.</p>
<h4 id="-_discussion_-"><strong><em>Discussion</em>:</strong></h4>
<p>Angular registers all startup module providers with the application root injector.
The services created from root injector providers are available to the entire application. 
They are <em>application-scoped</em>.</p>
<p>Certain services (e.g., the <code>Router</code>) only work when registered in the application root injector.</p>
<p>By contrast, Angular registers <code>AppComponent</code> providers with the <code>AppComponent</code>&#39;s own injector.
<code>AppComponent</code>services are available only to that component and its component tree. 
They are <em>component-scoped</em>.</p>
<p>The <code>AppComponent</code>&#39;s injector is a <em>child</em> of the root injector, one down in the injector hierarchy.
That is <em>almost</em> the entire application for apps that don&#39;t use the router.
But &quot;almost&quot; isn&#39;t good enough for routed applications.</p>
<p><code>AppComponent</code> services don&#39;t exist at the root level where routing operates. 
Lazy loaded modules can&#39;t reach them.
In the Angular Module Chapter sample applications, if we had registered <code>UserService</code> in the <code>AppComponent</code>, 
the <code>HeroComponent</code> couldn&#39;t inject it.
The application  would fail the moment a user navigated to &quot;Heroes&quot;.</p>
<div class="l-hr"></div><a id="q-component-or-module"></a><div class="l-main-section"></div><h3 id="should-i-add-other-providers-to-a-module-or-a-component-">Should I add other providers to a module or a component?</h3>
<p>In general, prefer registering feature-specific providers in modules (<code>@NgModule.providers</code>)
to registering in components (<code>@Component.providers</code>).</p>
<p>Register a provider with a component when you <em>must</em> limit the scope of a service instance
to that component and its component tree. 
Apply the same reasoning to registering a provider with a directive.</p>
<p>For example, a hero editing component that needs a private copy of a caching hero service should register
the <code>HeroService</code> with the <code>HeroEditorComponent</code>. 
Then each new instance of the <code>HeroEditorComponent</code> gets its own cached service instance. 
The changes that editor makes to heroes in its service do not touch the hero instances elsewhere in the application.</p>
<p><a href="q-root-component-or-module">Always register <em>application-wide</em> services with the root <code>AppModule</code></a>, 
not the root <code>AppComponent</code>.</p>
<div class="l-hr"></div><a id="q-why-bad"></a><div class="l-main-section"></div><h3 id="why-is-it-bad-if-_sharedmodule_-provides-a-service-to-a-lazy-loaded-module-">Why is it bad if <em>SharedModule</em> provides a service to a lazy loaded module?</h3>
<p>This question arose in the <a href="../guide/ngmodule.html#no-shared-module-providers">Angular Module</a> chapter 
when we discussed the importance of keeping providers out of the <code>SharedModule</code>.</p>
<p>Suppose we had listed the <code>UserService</code> in the module&#39;s <code>providers</code> (which we did not).
Suppose every module imports this <code>SharedModule</code> (which they all do).</p>
<p>When the app starts, Angular eagerly loads the <code>AppModule</code> and the <code>ContactModule</code>.</p>
<p>Both instances of the imported <code>SharedModule</code> would provide the <code>UserService</code>. 
Angular registers one of them in the root app injector (see <a href="#q-reimport">above</a>).
Then some component injects <code>UserService</code>, Angular finds it in the app root injector,
and delivers the app-wide singleton <code>UserService</code>. No problem. </p>
<p>Now consider the <code>HeroModule</code> <em>which is lazy loaded!</em></p>
<p>When the router lazy loads the <code>HeroModule</code>, it creates a child injector and registers the <code>UserService</code>
provider with that child injector. The child injector is <em>not</em> the root injector.</p>
<p>When Angular creates a lazy <code>HeroComponent</code>, it must inject a <code>UserService</code>.
This time it finds a <code>UserService</code> provider in the lazy module&#39;s <em>child injector</em>
and creates a <em>new</em> instance of the <code>UserService</code>.
This is an entirely different <code>UserService</code> instance
than the app-wide singleton version that Angular injected in one of the eagerly loaded components.</p>
<p>That&#39;s almost certainly a mistake.</p>
<div class="l-sub-section"><p>Prove it for yourself.
Run the <live-example name="ngmodule">live example</live-example>.
Modify the <code>SharedModule</code> so that it provides the <code>UserService</code> rather than the <code>CoreModule</code>.
Then toggle between the &quot;Contact&quot; and &quot;Heroes&quot; links a few times.
The username goes bonkers as the Angular creates a new <code>UserService</code> instance each time.</p>
</div><div class="l-hr"></div><a id="q-why-child-injector"></a><div class="l-main-section"></div><h3 id="why-does-lazy-loading-create-a-child-injector-">Why does lazy loading create a child injector?</h3>
<p>Angular adds <code>@NgModule.providers</code> to the application root injector ... unless the module is lazy loaded.
Then it creates a <em>child injector</em> and adds the module&#39;s providers to the child injector.</p>
<p>This means that a module behaves differently depending on whether it is loaded during application start
or lazy loaded later. Neglecting that difference can lead to <a href="#q-why-bad">adverse consequences</a>.</p>
<p>Why doesn&#39;t Angular add lazy loaded providers to the app root injector as it does for eagerly loaded modules? 
Why the inconsistency?</p>
<p>The answer is grounded in a fundamental characteristic of the Angular dependency injection system.
An injector can add providers <em>until it is first used</em>. 
Once an injector starts creating and delivering services, its provider list is frozen. No new providers allowed.</p>
<p>When an applications starts, Angular first configures the root injector with the providers of all eagerly loaded modules
<em>before</em> creating its first component and injecting any of the provided services. 
Once the application begins, the app root injector is closed to new providers.</p>
<p>Time passes. Application logic triggers lazy loading of a module.
Angular must add the lazy loaded module&#39;s providers to an injector <em>somewhere</em>. 
It can&#39;t added them to the app root injector because that injector is closed to new providers. 
So Angular creates a new child injector for the lazy loaded module context.</p>
<div class="l-hr"></div><a id="q-is-it-loaded"></a><div class="l-main-section"></div><h3 id="how-can-i-tell-if-a-module-or-service-was-previously-loaded-">How can I tell if a module or service was previously loaded?</h3>
<p>Some modules and its services should only be loaded once by the root <code>AppModule</code>.
Importing the module a second time by lazy loading a module could <a href="#q-why-bad">produce errant behavior</a> 
that may be difficult to detect and diagnose.</p>
<p>We can guard against that danger by writing a constructor that attempts to inject the module or service
from the root app injector. If the injection succeeds, the class has been loaded a second time.
We can throw an error or take other remedial action.</p>
<p>Certain Angular modules (such as <code>BrowserModule</code>) implements such a guard 
as does this Angular Module chapter sample&#39;s <code>CoreModule</code> constructor.</p>
<div class="code-example"><header><h4>app/core/core.module.ts (Constructor)</h4></header><code-example language="ts" format="">constructor (@Optional() @SkipSelf() parentModule: CoreModule) {
  if (parentModule) {
    throw new Error(
      &#39;CoreModule is already loaded. Import it in the AppModule only&#39;);
  }
}
</code-example></div><div class="l-hr"></div><a id="q-entry-component-defined"></a><div class="l-main-section"></div><h3 id="what-is-an-_entry-component_-">What is an <em>entry component</em>?</h3>
<p>Any component that Angular loads <em>imperatively</em> by type is an <em>entry component</em>,</p>
<p>A component loaded <em>declaratively</em> via its selector is <em>not</em> an entry component.</p>
<p>Most application components are loaded declaratively. 
Angular uses the component&#39;s selector to locate the element in the template. 
It then creates the HTML representation of the component and inserts it into the DOM at the selected element.
These are not entry components.</p>
<p>A few components are only loaded dynamically and are <em>never</em> referenced in a component template. </p>
<p>The bootstrapped root <code>AppComponent</code> is an <em>entry component</em>.
True, its selector matches an element tag in <code>index.html</code>.
But <code>index.html</code> is not a component template and the <code>AppComponent</code> 
selector doesn&#39;t match an element in any component template.</p>
<p>Angular loads <code>AppComponent</code> dynamically either because we listed it <em>by type</em> in <code>@NgModule.bootstrap</code> 
or because we boostrapped it imperatively with the module&#39;s <code>ngDoBootstrap</code> method.</p>
<p>Components in route definitions are also <em>entry components</em>.
A route definition refers to a component by its <em>type</em>. 
The router ignores a routed component&#39;s selector (if it even has one) and 
loads the component dynamically into a <code>RouterOutlet</code>. </p>
<p>The compiler can&#39;t discover these <em>entry components</em> by looking for them in other component templates. 
We must tell it about them ... by adding them to the <code>entryComponents</code> list.</p>
<p>Angular automatically adds two kinds of components to the module&#39;s <code>entryComponents</code>:</p>
<ol>
<li>the component in the <code>@NgModule.bootstrap</code> list</li>
<li>components referenced in router configuration</li>
</ol>
<p>We don&#39;t have to mention these components explicitly although it does not harm to do so.</p>
<div class="l-hr"></div><a id="q-bootstrap_vs_entry_component"></a><div class="l-main-section"></div><h3 id="what-s-the-difference-between-a-_bootstrap_-component-and-an-_entry-component_-">What&#39;s the difference between a <em>bootstrap</em> component and an <em>entry component</em>?</h3>
<p>A bootstrapped component <em>is</em> an <a href="#q-entry-component-defined">entry component</a>.
It&#39;s an entry component that Angular loads into the DOM during the bootstrap (application launch) process.
Other entry components are loaded dynamically by other means such as with the router.</p>
<p>The <code>@NgModule.bootstrap</code> property tells the compiler <em>both</em> that this is an entry component <em>and</em>
that it should generate code to bootstrap the application with this component.</p>
<p>There is no need to list a component in both the <code>bootstrap</code> and <code>entryComponent</code> lists 
although it is harmless to do so.</p>
<div class="l-hr"></div><a id="q-when-entry-components"></a><div class="l-main-section"></div><h3 id="when-do-i-add-components-to-_entrycomponents_-">When do I add components to <em>entryComponents</em>?</h3>
<p>Most application developers won&#39;t need to add components to the <code>entryComponents</code>.</p>
<p>Angular adds certain components to <em>entry components</em> automatically.
Components listed in <code>@NgModule.bootstrap</code> are added automatically.
Components referenced in router configuration are added automatically.
These two mechanisms account for almost all entry components.</p>
<p>If your app happens to bootstrap or dynamically load a component <em>by type</em> in some other manner, 
you&#39;ll have to add it to <code>entryComponents</code> explicitly.</p>
<p>Although it&#39;s harmless to add components to this list,
it&#39;s best to add only the components that are truly <em>entry components</em>.
Don&#39;t include components that <a href="#q-template-reference">are referenced</a> 
in the templates of other components.</p>
<div class="l-hr"></div><a id="q-why-entry-components"></a><div class="l-main-section"></div><h3 id="why-does-angular-need-_entrycomponents_-">Why does Angular need <em>entryComponents</em>?</h3>
<p><em>Entry components</em> are also declared.
Why doesn&#39;t the Angular compiler generate code for every component in <code>@NgModule.declarations</code>?
Then we wouldn&#39;t need entry components.</p>
<p>The reason is <em>tree shaking</em>. For production apps we want to load the smallest, fastest code possible.
The code should contain only the classes that we actually need.
It should exclude a component that&#39;s never used, whether or not that component is declared.</p>
<p>In fact, many libraries declare and export components we&#39;ll never use.
The <em>tree shaker</em> will drop these components from the final code package
if we don&#39;t reference them. </p>
<p>If the <a href="#q-angular-compiler">Angular compiler</a> generated code for every declared component, 
it would defeat the purpose of the tree shaker.</p>
<p>Instead, the compiler adopts a recursive strategy that generates code only for the components we use.</p>
<p>It starts with the entry components, 
then it generates code for the declared components it <a href="#q-template-reference">finds</a> in an entry component&#39;s template,
then for the declared components it discovers in the templates of previously compiled components,
and so on. At the end of the process, it has generated code for every  entry component
and every component reachable from an entry component.</p>
<p>If a component isn&#39;t an <em>entry component</em> or wasn&#39;t found in a template, 
the compiler omits it. </p>
<div class="l-hr"></div><a id="q-module-recommendations"></a><div class="l-main-section"></div><h4 id="what-kinds-of-modules-should-i-have-and-how-should-i-use-them-">What kinds of modules should I have and how should I use them?</h4>
<p>Every app is different and developers have varying levels of experience and comfort with the available choices.
Some suggestions and guidelines appear to have wide appeal.</p>
<div class="alert is-important"><p>The following is preliminary guidance based on early experience using Angular modules in a few applications.
Read with appropriate caution and reflection.</p>
</div><h4 id="_sharedmodule_"><em>SharedModule</em></h4>
<p>Create a <code>SharedModule</code> with the components, directives, and pipes that you use
everywhere in your app. This module should consist entirely of <code>declarations</code>
most of them exported. </p>
<p>It may re-export other <a href="#widget-feature-module">widget modules</a> such as <code>CommonModule</code>,
<code>FormsModule</code> and modules with the UI controls that you use most widely.</p>
<p>It should <strong><em>not</em></strong> have <code>providers</code> for reasons <a href="#q-why-bad">explained earlier</a>.
Nor should any of its imported or re-exported modules have <code>providers</code>.
Know what you&#39;re doing and why if you deviate from this guideline.</p>
<p>Import the <code>SharedModule</code> in your <em>feature</em> modules, 
both those loaded when the app starts and those you lazy load later.</p>
<h4 id="_coremodule_"><em>CoreModule</em></h4>
<p>Create a <code>CoreModule</code> with <code>providers</code> for the singleton services you load when the application starts.</p>
<p>Import <code>CoreModule</code> in the root <code>AppModule</code> only.
Never import <code>CoreModule</code> in any module other than the root <code>AppModule</code>.</p>
<p>Consider making <code>CoreModule</code> a <a href="#service-feature-module">pure services module</a> with no <code>declarations</code>.</p>
<div class="l-sub-section"><p>This chapter sample departs from that advice by declaring and exporting two components that are
only used within the root <code>AppComponent</code> declared by <code>AppModule</code>. 
Someone following this guideline strictly would have declared these components in the <code>AppModule</code> instead.</p>
</div><h4 id="feature-modules">Feature Modules</h4>
<p>Create <em>Feature Modules</em> around specific application business domains, user workflows, and utility collections.</p>
<p>Feature modules tend to fall into one of these four groups:</p>
<ul>
<li><a href="#domain-feature-module">Domain Feature Modules</a></li>
<li><a href="#routed-feature-module">Routed Feature Modules</a></li>
<li><a href="#service-feature-module">Service Feature Modules</a></li>
<li><a href="#widget-feature-module">Widget Feature Modules</a></li>
</ul>
<div class="l-sub-section"><p>Real world modules are often hybrids that knowingly deviate from the following guidelines.
They are guidelines, not laws.
Follow them until you have a good reason to do otherwise.</p>
</div><table><tr><th style="vertical-align: top">Feature Module</th><th style="vertical-align: top">Guidelines</th></tr><tr><td style="vertical-align: top"><a id="domain-feature-module"></a>Domain</td><td><p>Domain Feature Modules deliver a user experience <strong>dedicated to a particular application domain</strong>
like editing a customer or placing an order.</p>
<p>They typically have a top component that acts as the feature root.
Private, supporting sub-components descend from it.</p>
<p>Domain feature module consist mostly of <em>declarations</em>.
Only the top component is exported.</p>
<p>Domain feature modules rarely have <em>providers</em>.
When they do, the lifetime of the provided services
should be the same as the lifetime of the module.</p>
<p>Do not provide application-wide singleton services in a domain feature module.</p>
<p>Domain feature modules are typically imported <em>exactly once</em> by a larger feature module.</p>
<p>They might be imported by the root <code>AppModule</code> of a small application that lacks routing.</p>
<div class="l-sub-section"><p>For an example, see <a href="../guide/ngmodule.html#contact-module-v1"><em>ContactModule</em></a> 
in the Angular Module chapter, before we introduced routing.</p>
</div></td></tr><tr><td style="vertical-align: top"><a id="routed-feature-module"></a>Routed</td><td><p><em>Routed Feature Modules</em> are <em>Domain Feature modules</em> 
whose top components are the <strong>targets of router navigation routes</strong>.</p>
<p>All lazy loaded modules are routed feature modules by definition.</p>
<p>This chapter&#39;s <code>ContactModule</code>, <code>HeroModule</code> and <code>CrisisModule</code> are routed feature modules.</p>
<p>Routed Feature Modules <em>should not export anything</em>. 
They don&#39;t have to because none of their components ever appear in the template of an external component.</p>
<p>A lazy loaded Routed Feature Module should <em>not be imported</em> by any module. 
Doing so would trigger an eager load, defeating the purpose of lazy loading.
<code>HeroModule</code> and <code>CrisisModule</code> are lazy loaded. They aren&#39;t mentioned among the <code>AppModule</code> imports.</p>
<p>But an eager loaded Routed Feature Module must be imported by another module
so that the compiler learns about its components. 
<code>ContactModule</code> is eager loaded and, therefore, is listed among the <code>AppModule</code> imports.</p>
<p>Routed Feature Modules rarely have <em>providers</em> for reasons <a href="#q-why-bad">explained earlier</a>.
When they do, the lifetime of the provided services
should be the same as the lifetime of the module.</p>
<p>Do not provide application-wide singleton services in a routed feature module
or in a module that the routed module imports.</p>
</td></tr><tr><td style="vertical-align: top"><a id="service-feature-module"></a>Service</td><td><p><em>Service Modules</em> <strong>provide utility services</strong> such as data access and messaging.</p>
<p>Ideally they consist entirely of <em>providers</em> and have no <em>declarations</em>.
The <code>CoreModule</code> and Angular&#39;s <code>HttpModule</code> are good examples.</p>
<p>Service Modules should <em>only</em> be imported by the root <code>AppModule</code>.</p>
<p>Do <strong>not</strong> import them in other feature modules.
Know what you&#39;re doing and why if you deviate from this guideline.</p>
</td></tr><tr><td style="vertical-align: top"><a id="widget-feature-module"></a>Widget</td><td><p>A <em>Widget Module</em> makes <strong>components, directives, and pipes</strong> available to external modules.</p>
<p><code>CommonModule</code> and <code>SharedModule</code> are widget modules.
Many third party UI component libraries are widget modules.</p>
<p>A Widget Module should consist entirely of <em>declarations</em>, most of them exported. </p>
<p>A Widget Module should rarely have <em>providers</em>. 
Know what you&#39;re doing and why if you deviate from this guideline.</p>
<p>Import Widget Modules in any module whose component templates need the widgets.</p>
</td></tr></table><p>The following table summarizes the key characteristics of each <em>Feature Module</em> group.</p>
<div class="l-sub-section"><p>Real world modules are often hybrids that knowingly deviate from these guidelines.</p>
</div><table><tr><th>Feature Module</th><th>Declarations </th><th>Providers </th><th>Exports</th><th>Imported By</th><th>Examples</th></tr><tr><td>Domain</td><td>Yes</td><td>Rare</td><td>Top Component</td><td>Feature, <code>AppModule</code></td><td><code>ContactModule</code> (before routing)</td></tr><tr><td>Routed</td><td>Yes</td><td>Rare</td><td>No</td><td>Nobody</td><td><code>ContactModule</code>, <code>HeroModule</code>, <code>CrisisModule</code></td></tr><tr><td>Service</td><td>No</td><td>Yes</td><td>No</td><td><code>AppModule</code></td><td><code>HttpModule</code>, <code>CoreModule</code></td></tr><tr><td>Widget</td><td>Yes</td><td>Rare</td><td>Yes</td><td>Feature</td><td><code>CommonModule</code>, <code>SharedModule</code></td></tr></table><div class="l-hr"></div><a id="q-ng-vs-js-modules"></a><div class="l-main-section"></div><h3 id="what-s-the-difference-between-angular-and-javascript-modules-">What&#39;s the difference between Angular and JavaScript Modules?</h3>
<p>Angular and JavaScript are two different yet complementary module systems.</p>
<p>In modern JavaScript, <a href="http://exploringjs.com/es6/ch_modules.html">every file is a <em>module</em></a>.
Within each file we write an <code>export</code> statement to make parts of the module public:</p>
<code-example format=".">export class AppComponent { ... }
</code-example><p>Then we <code>import</code> a part in another module:</p>
<code-example format=".">import { AppComponent }  from './app.component';
</code-example><p>This kind of modularity is a feature of the <em>JavaScript language</em>.</p>
<p>An <em>Angular Module</em> is a feature of <em>Angular</em> itself.</p>
<p>Angular&#39;s <code>NgModule</code> also has <code>imports</code> and <code>exports</code> and they serve a similar purpose. </p>
<p>We <em>import</em> other Angular modules so we can use their exported classes in component templates.
We <em>export</em> this Angular module&#39;s classes so they can be imported and used by components of <em>other</em> modules.</p>
<p>The Angular module classes differ from JavaScript module class in three key respects:</p>
<ol>
<li><p>An Angular module bounds <a href="#q-declarables"><em>declarable classes</em></a> only. 
Declarables are the only classes that matter to the <a href="#q-angular-compiler">Angular compiler</a>.</p>
</li>
<li><p>Instead of defining all member classes in one giant file (as in a JavaScript module),
we list the module&#39;s classes in the <code>@NgModule.declarations</code> list.</p>
</li>
<li><p>An Angular module can only export the <a href="#q-declarables"><em>declarable classes</em></a> 
it owns or imports from other modules.
It doesn&#39;t declare or export any other kind of class.</p>
</li>
</ol>
<p>The Angular Module is also special in another way.
Unlike JavaScript modules, an Angular module can extend the <em>entire</em> application with services
by adding providers to the <code>@NgModule.providers</code> list.</p>
<div class="alert is-important"><p>The provided services do not belong to the module nor are they scoped to the declared classes.
They are available <em>everywhere</em>.</p>
</div><p>Here&#39;s an <em>Angular Module</em> class with imports, exports, and declarations.</p>
<div class="code-example"><code-example language="ts" format="">@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code-example></div><p>Of course we use <em>JavaScript</em> modules to write <em>Angular</em> modules as seen in the complete <code>contact.module.ts</code> file:</p>
<div class="code-example"><header><h4>app/contact/contact.module.ts</h4></header><code-example language="ts" format="">import { NgModule }           from &#39;@angular/core&#39;;
import { CommonModule }       from &#39;@angular/common&#39;;
import { FormsModule }        from &#39;@angular/forms&#39;;

import { AwesomePipe }        from &#39;./awesome.pipe&#39;;

import
       { ContactComponent }   from &#39;./contact.component&#39;;
import { ContactService }     from &#39;./contact.service&#39;;
import { HighlightDirective } from &#39;./highlight.directive&#39;;

@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code-example></div><div class="l-hr"></div><a id="q-template-reference"></a><div class="l-main-section"></div><h4>How does Angular find components, directives, and pipes in a template?<br>What is a <i><b>template reference</b></i>?</h4><p>The <a href="#q-angular-compiler">Angular compiler</a> looks inside component templates 
for other components, directives, and pipes. When it finds one, that&#39;s a &quot;template reference&quot;.</p>
<p>The Angular compiler finds a component or directive in a template when it can match the <strong>selector</strong> of that 
component or directive to some HTML in that template. </p>
<p>The compiler finds a pipe if the pipe&#39;s <strong>name</strong> appears within the pipe syntax of the template HTML.</p>
<p>Angular only matches selectors and pipe names for classes that are declared by this module
or exported by a module that this module imports.</p>
<div class="l-hr"></div><a id="q-angular-compiler"> </a><div class="l-main-section"></div><h3 id="what-is-the-angular-compiler-">What is the Angular Compiler?</h3>
<p>The <em>Angular Compiler</em> converts the application code we write into highly performant JavaScript code.
The <code>@NgModule</code> metadata play an important role in guiding the compilation process.</p>
<p>The code we write is not immediately executable.
Consider <strong>components</strong>.
Components have templates that contain custom elements, attribute directives, Angular binding declarations, 
and some peculiar syntax that clearly isn&#39;t native HTML.</p>
<p>The <em>Angular Compiler</em> reads the template markup, 
combines it with the corresponding component class code, and emits <em>component factories</em>.</p>
<p>A component factory creates a pure, 100% JavaScript representation
of the component that incorporates everything described in its <code>@Component</code> metadata: 
the HTML, the binding instructions, the attached styles ... everything.</p>
<p>Because <strong>directives</strong> and <strong>pipes</strong> appear in component templates, 
the <em>Angular Compiler</em> incorporates them into compiled component code too.</p>
<p><code>@NgModule</code> metadata tells the <em>Angular Compiler</em> what components to compile for this module and 
how to link this module with other modules.</p>
<div class="l-hr"></div><a id="q-ngmodule-api"> </a><div class="l-main-section"></div><h2 id="-ngmodule-api"><em>NgModule</em> API</h2>
<p>The following chart summarizes the <code>NgModule</code> metadata properties.</p>
<!--export interface NgModuleMetadataType {
  providers?: any[];
  declarations?: Array<Type|any[]>;
  imports?: Array<Type|ModuleWithProviders|any[]>;
  exports?: Array<Type|any[]>;
  entryComponents?: Array<Type|any[]>;
  bootstrap?: Array<Type|any[]>;
  schemas?: Array<SchemaMetadata|any[]>;
}
--><table><tr><th>Property</th><th>Description</th></tr><tr><td style="vertical-align: top"><code>declarations</code></td><td><p>A list of <a href="#q-declarables">declarable</a> classes, 
the <strong>component</strong>, <strong>directive</strong> and <strong>pipe</strong> classes that <em>belong to this module</em>.</p>
<p>These declared classes are visible within the module but invisible to
components in a different module unless (a) they are <em>exported</em> from this module and 
(b) that other module <em>imports</em> this one.</p>
<p>Components, directives and pipes must belong to <em>exactly</em> one module.
The compiler emits an error if we try to declare the same class in more than one module.</p>
<p><strong>Do not re-declare a class imported from another module.</strong></p>
</td></tr><tr><td style="vertical-align: top"><code>providers</code></td><td><p>A list of dependency injection providers.</p>
<p>Angular registers these providers with the root injector of the module&#39;s execution context.
That&#39;s the application&#39;s root injector for all modules loaded when the application starts.</p>
<p>Angular can inject one of these provider services into any component in the application.
If this module provides the <code>HeroService</code>, or any module loaded at launch provides the <code>HeroService</code>,
Angular can inject the same <code>HeroService</code> intance into any app component.</p>
<p>A lazy loaded module has its own sub-root injector which typically 
is a direct child of the application root injector.</p>
<p>Lazy loaded services are scoped to the lazy module&#39;s injector.
If a lazy loaded module also provides the <code>HeroService</code>, 
any component created within that module&#39;s context (e.g., by router navigation)
gets the local instance of the service, not the instance in the root application injector.</p>
<p>Components in external modules continue to receive the instance created for the application root. </p>
</td></tr><tr><td style="vertical-align: top"><code>imports</code></td><td><p>A list of supporting modules.</p>
<p>Specifically, the list of modules whose exported components, directives or pipes 
are referenced by the component templates declared in this module.</p>
<p>A component template can <a href="#q-template-reference">reference</a> another component, directive or pipe
on two conditions: either the referenced class is declared in this module
or the class was imported from another module. </p>
<p>A component can use the <code>NgIf</code> and <code>NgFor</code> directives only because its parent module 
imported the Angular <code>CommonModule</code> (perhaps indirectly by importing <code>BrowserModule</code>).</p>
<p>We can import many standard directives with the <code>CommonModule</code>.
But some familiar directives belong to other modules.
A component template can bind with <code>[(ngModel)]</code> only after importing the Angular <code>FormsModule</code>.</p>
</td></tr><tr><td style="vertical-align: top"><code>exports</code></td><td><p>A list of declarations &mdash; <strong>component</strong>, <strong>directive</strong>, and <strong>pipe</strong> classes &mdash; that 
an importing module can use.</p>
<p>Exported declarations are the module&#39;s <em>public API</em>. 
A component in another module can <a href="#q-template-reference">reference</a> <em>this</em> module&#39;s <code>HeroComponent</code> 
if (a) it imports this module and (b) this module exports <code>HeroComponent</code>.</p>
<p>Declarations are private by default.
If this module does <em>not</em> export <code>HeroComponent</code>, no other module can see it.</p>
<p>Importing a module does <em>not</em> automatically re-export the imported module&#39;s exports.
Module &#39;B&#39; can&#39;t use <code>ngIf</code> just because it imported module <code>A</code> which imported <code>CommonModule</code>.
Module &#39;B&#39; must import <code>CommonModule</code> itself.</p>
<p>A module can list another module among its <code>exports</code> in which case
all of that module&#39;s public components, directives, and pipes are exported.</p>
<p><a href="#q-re-export">Re-export</a> makes module transitivity explicit.
If Module &#39;A&#39; re-exports <code>CommonModule</code> and Module &#39;B&#39; imports Module &#39;A&#39;,
Module &#39;B&#39; components can use <code>ngIf</code> even though &#39;B&#39; itself didn&#39;t import <code>CommonModule</code>.</p>
</td></tr><tr><td style="vertical-align: top"><code>bootstrap</code></td><td><p>A list of components that can be bootstrapped.</p>
<p>Usually there is only one component in this list, the <em>root component</em> of the application.</p>
<p>Angular can launch with multiple bootstrap components, 
each with its own location in the host web page.</p>
<p>A bootstrap component is automatically an <code>entryComponent</code> </p>
</td></tr><tr><td style="vertical-align: top"><code>entryComponents</code></td><td><p>A list of components that are <em>not</em> <a href="#q-template-reference">referenced</a> in a reachable component template.</p>
<p>Most developers will never set this property. Here&#39;s why.</p>
<p>The <a href="#q-angular-compiler"><em>Angular Compiler</em></a> must know about every component actually used in the application.
The compiler can discover most components by walking the tree of references 
from one component template to another.</p>
<p>But there&#39;s always at least one component that is not referenced in any template:
the root component, <code>AppComponent</code>, that we bootstrap to launch the app.
That&#39;s why it&#39;s called an <em>entry component</em>.</p>
<p>Routed components are also <em>entry components</em> because they aren&#39;t referenced in a template either.
The router creates them and drops them into the DOM near a <code>&lt;router-outlet&gt;</code>.</p>
<p>While the bootstrapped and routed components are <em>entry components</em>, 
we usally don&#39;t have to add them to a module&#39;s <code>entryComponents</code> list.</p>
<p>Angular automatically adds components in the module&#39;s <code>bootstrap</code> list to the <code>entryComponents</code> list.
The <code>RouterModule</code> adds routed components to that list.</p>
<p>That leaves only two sources of undiscoverable components.</p>
<ol>
<li>Components bootstrapped using one of the imperative techniques.</li>
<li>Components dynamically loaded into the DOM by some means other than the router.</li>
</ol>
<p>Both are advanced techniques that few developers will ever employ. 
If you are one of those few, you&#39;ll have to add these components to the 
<code>entryComponents</code> list yourself, either programmatically or by hand.</p>
</td></tr></table></article><div class="main-footer"><nav class="background-midnight grid-fluid"><div class="c3 main-footer-branding"><div class="logo-inverse-large"></div></div><div class="c2"><h3 class="text-headline">RESOURCES</h3><ul class="text-body"><!-- TODO: (ericjim) make a libraries page to showcase all angular 2 libraries--><!--li <a href="/libraries.html">Libraries</a>--><li><a href="/about/">About</a></li><li><a href="/resources/">Books & Training</a></li><li><a href="/resources/">Tools & Libraries</a></li><li><a href="/resources/">Community</a></li><li><a href="/presskit.html">Press Kit</a></li></ul></div><div class="c2"><h3 class="text-headline">HELP</h3><ul class="text-body"><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><a href="https://github.com/angular/angular/issues"> Report Issues</a></li><li><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> Site Feedback</a></li></ul></div><div class="c2"><h3 class="text-headline">COMMUNITY</h3><ul class="text-body"><li><a href="/events.html">Events</a></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="https://twitter.com/angularjs"> Twitter</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><a href="/contribute.html"> Contribute</a></li></ul></div><div class="c2"><h3 class="text-headline">LANGUAGES</h3><ul class="text-body"><li><a href="https://angular.cn/">中文版</a></li></ul></div></nav><footer class="background-midnight"><small class="text-caption">Powered by Google ©2010-2016. Code licensed under an <a href="/license" class="text-snow">MIT-style License</a>. Documentation licensed under <a class="text-snow" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</small><a aria-label="View Style Guide" href="/docs/ts/latest/styleguide.html" title="Style Guide" class="styleguide-trigger text-snow"><span class="icon-favorite"></span></a></footer></div><!-- VENDORS --><script src="/resources/js/vendor/prettify.js"></script><script src="/resources/js/vendor/lang-basic.js"></script><script src="/resources/js/vendor/lang-dart.js"></script><script src="/resources/js/vendor/lodash.js"></script><script src="/resources/js/vendor/clipboard.min.js"></script><!-- Angular Material Dependencies --><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-animate.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular-aria.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.js"></script><!-- Firebase -->
<script src="https://cdn.firebase.com/js/client/2.2.4/firebase.js"></script>
<!-- AngularFire -->
<script src="https://cdn.firebase.com/libs/angularfire/1.2.0/angularfire.min.js"></script>
<!-- Angular.io Site JS --><script src="/resources/js/site.js"></script><script src="/resources/js/util.js"></script><script src="/resources/js/controllers/app-controller.js"></script><script src="/resources/js/controllers/resources-controller.js"></script><script src="/resources/js/directives/cheatsheet.js"></script><script src="/resources/js/directives/api-list.js"></script><script src="/resources/js/directives/bio.js"></script><script src="/resources/js/directives/bold.js"></script><script src="/resources/js/directives/announcement-bar.js"></script><script src="/resources/js/directives/code.js"></script><script src="/resources/js/directives/copy.js"></script><script src="/resources/js/directives/code-tabs.js"></script><script src="/resources/js/directives/code-pane.js"></script><script src="/resources/js/directives/code-example.js"></script><script src="/resources/js/directives/if-docs.js"></script><script src="/resources/js/directives/live-example.js"></script><script src="/resources/js/directives/ngio-ex-path.js"></script><script src="/resources/js/directives/scroll-y-offset-element.js"></script><!-- GA --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-8594346-15', 'auto');
ga('send', 'pageview')

</script><!-- SWIFTYPE --><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

_st('install','VsuU7kH5Hnnj9tfyNvfK');
</script><!-- Google Feedback --><script src="//www.gstatic.com/feedback/api.js" type="text/javascript"></script><!-- Twitter Widget --><script>(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}})(document,"script","twitter-wjs");</script></body></html>